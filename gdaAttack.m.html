<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>gdaAttack API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#gdaAttack.flgCacheThreadStarted">flgCacheThreadStarted</a></li>
    <li class="mono"><a href="#gdaAttack.signal_kill_received">signal_kill_received</a></li>
    <li class="mono"><a href="#gdaAttack.theCacheQueue">theCacheQueue</a></li>
    <li class="mono"><a href="#gdaAttack.theCacheThreadObject">theCacheThreadObject</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#gdaAttack.on_exit">on_exit</a></li>
    <li class="mono"><a href="#gdaAttack.printTitle">printTitle</a></li>
    <li class="mono"><a href="#gdaAttack.signal_kill_handler">signal_kill_handler</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#gdaAttack.CacheThread">CacheThread</a></span>
        
          
  <ul>
    <li class="mono"><a href="#gdaAttack.CacheThread.__init__">__init__</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.getName">getName</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.isAlive">isAlive</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.isDaemon">isDaemon</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.is_alive">is_alive</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.join">join</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.run">run</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.setDaemon">setDaemon</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.setName">setName</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.start">start</a></li>
    <li class="mono"><a href="#gdaAttack.CacheThread.terminate">terminate</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#gdaAttack.EnhancedThread">EnhancedThread</a></span>
        
          
  <ul>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.__init__">__init__</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.getName">getName</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.isAlive">isAlive</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.isDaemon">isDaemon</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.is_alive">is_alive</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.join">join</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.run">run</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.setDaemon">setDaemon</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.setName">setName</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.start">start</a></li>
    <li class="mono"><a href="#gdaAttack.EnhancedThread.terminate">terminate</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#gdaAttack.gdaAttack">gdaAttack</a></span>
        
          
  <ul>
    <li class="mono"><a href="#gdaAttack.gdaAttack.__init__">__init__</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.askAttack">askAttack</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.askClaim">askClaim</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.askExplore">askExplore</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.askKnowledge">askKnowledge</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.cleanUp">cleanUp</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getAttack">getAttack</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getAttackTableName">getAttackTableName</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getClaim">getClaim</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getColNames">getColNames</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getColNamesAndTypes">getColNamesAndTypes</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getExplore">getExplore</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getKnowledge">getKnowledge</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getOpParameters">getOpParameters</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getPriorKnowledge">getPriorKnowledge</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getPublicColValues">getPublicColValues</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getResults">getResults</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getTableCharacteristics">getTableCharacteristics</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getTableNames">getTableNames</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.getUidColName">getUidColName</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.putCacheWrapper">putCacheWrapper</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.setVerbose">setVerbose</a></li>
    <li class="mono"><a href="#gdaAttack.gdaAttack.unsetVerbose">unsetVerbose</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">gdaAttack</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack" class="source">
    <pre><code>import sqlite3
import simplejson
import psycopg2
import queue
import threading
import sys
import os
import copy
import base64
import time
import pprint
import datetime
import signal
import atexit
import random

try:
    pass
except ImportError:
    pass

theCacheQueue = None
theCacheThreadObject = None
flgCacheThreadStarted = False

class gdaAttack:
    """Manages a GDA Attack

       See __init__ for input parameters. <br/>
       WARNING: this code is fragile, and can fail ungracefully, or
       just hang."""

    def __init__(self, params):
        """ Sets everything up with 'gdaAttack(params)'

            params is a dictionary containing the following
            required parameters: <br/>
            `param['name']`: The name of the attack. Make it unique, because
            the cache is discovered using this name. <br/>
            `param['rawDb']`: The label for the DB to be used as the
            raw (non-anonymized) DB. <br/>
            Following are the optional parameters: <br/>
            `param['criteria']`: The criteria by which the attack should
            determined to succeed or fail. Must be one of 'singlingOut',
            'inference', or 'linkability'. Default is 'singlingOut'. <br/>
            `param['anonDb']`: The label for the DB to be used as the
            anonymized DB. (Is automatically set to `param['rawDb']` if
            not set.) <br/>
            `param['pubDb']`: The label for the DB to be used as the
            publicly known DB in linkability attacks. <br/>
            `param['table']`: The table to be attacked. Must be present
            if the DB has more than one table. <br/>
            `param['uid']`: The uid column for the table. Must be present
            if the name of the column is other than 'uid'. <br/>
            `param['flushCache']`: Set to true if you want the cache of
            query answers from a previous run flushed. The purpose of the
            cache is to save the work from an aborted attack, which can be
            substantial because attacks can have hundreds of queries. <br/>
            `param['locCacheDir']`: The directory holding the cache DBs.
            Default 'cacheDBs'. <br/>
            `param['numRawDbThreads']`: The number of parallel queries
            that can be made to the raw DB. Default 3. <br/>
            `param['numAnonDbThreads']`: The number of parallel queries
            that can be made to the anon DB. Default 3. <br/>
            `param['numPubDbThreads']`: The number of parallel queries
            that can be made to the public linkability DB. Default 3. <br/>
            `param['verbose']`: Set to True for verbose output.
        """

        ########### added by frzmohammadali ##########
        global theCacheQueue
        global theCacheThreadObject
        global flgCacheThreadStarted

        if not theCacheQueue and not theCacheThreadObject:
            theCacheQueue = queue.Queue()
            theCacheThreadObject = CacheThread(theCacheQueue, self)
            printTitle('cache thread initialized.')

        self.cacheQueue = theCacheQueue
        self.cacheThreadObject = theCacheThreadObject
        if not flgCacheThreadStarted:
            self.cacheThreadObject.start()
            flgCacheThreadStarted = True
        ##############################################

        ############## parameters and instance variables ###############
        # ------------- Class called parameters and configured parameters
        self._vb = False
        self._cr = ''  # short for criteria
        self._pp = None  # pretty printer (for debugging)
        self._colNamesTypes = []
        self._colNames = []
        self._p = dict(name='',
                  rawDb='',
                  anonDb='',
                  pubDb='',
                  criteria='singlingOut',
                  table='',
                  uid='uid',
                  flushCache=False,
                  verbose=False,
                  # following not normally set by caller, but can be
                  locCacheDir="cacheDBs",
                  numRawDbThreads=3,
                  numAnonDbThreads=3,
                  numPubDbThreads=3,
                  )
        self._requiredParams = ['name', 'rawDb']

        # ---------- Private internal state
        # Threads
        self._rawThreads = []
        self._anonThreads = []
        self._pubThreads = []
        # Queues read by database threads _rawThreads and _anonThreads
        self._rawQ = None
        self._anonQ = None
        self._pubQ = None
        # Queues read by various caller functions
        self._exploreQ = None
        self._knowledgeQ = None
        self._attackQ = None
        self._claimQ = None
        self._guessQ = None
        # ask/get counters for setting 'stillToCome'
        self._exploreCounter = 0
        self._knowledgeCounter = 0
        self._attackCounter = 0
        self._claimCounter = 0
        self._guessCounter = 0
        # State for computing attack results (see _initAtkRes())
        self._atrs = {}
        # State for various operational measures (see _initOp())
        self._op = {}
        ##############################################

        if self._vb:
            print(f"Calling {__name__}.init")
        if self._vb:
            print(f"   {params}")
        self._initOp()
        self._initCounters()
        self._assignGlobalParams(params)
        self._doParamChecks()
        for param in self._requiredParams:
            if len(self._p[param]) == 0:
                s = str(f"Error: Need param '{param}' in class parameters")
                sys.exit(s)
        # create the database directory if it doesn't exist
        try:
            if not os.path.exists(self._p['locCacheDir']):
                os.makedirs(self._p['locCacheDir'])
        except OSError:
            sys.exit("Error: Creating directory. " + self._p['locCacheDir'])

        # Get the table name if not provided by the caller
        if len(self._p['table']) == 0:
            tables = self.getTableNames()
            if len(tables) != 1:
                print("Error: gdaAttack(): Must include table name if " +
                      "there is more than one table in database")
                sys.exit()
            self._p['table'] = tables[0]

        # Get the column names for computing susceptibility later
        self._colNamesTypes = self.getColNamesAndTypes()
        if self._vb:
            print(f"Columns are '{self._colNamesTypes}'")
        self._initAtkRes()
        # And make a convenient list of column names
        for colNameType in self._colNamesTypes:
            self._colNames.append(colNameType[0])

        # Setup the database which holds already executed queries so we
        # don't have to repeat them if we are restarting
        self._setupLocalCacheDB()
        # Setup the threads and queues
        self._setupThreadsAndQueues()
        numThreads = threading.active_count()
        expectedThreads = (self._p['numRawDbThreads'] +
                           self._p['numAnonDbThreads'] + 1)
        if len(self._p['pubDb']) > 0:
            expectedThreads += self._p['numPubDbThreads']
        if numThreads < expectedThreads:
            print(f"Error: Some thread(s) died "
                  f"(count {numThreads}, expected {expectedThreads}). "
                  f"Aborting.")
            self.cleanUp(cleanUpCache=False, doExit=True)

    def getResults(self):
        """ Returns all of the compiled attack results.

            This can be input to class `gdaScores()` and method
            `gdaScores.addResult()`."""
        # Add the operational parameters
        self._atrs['operational'] = self.getOpParameters()
        self._cleanPasswords()
        return self._atrs

    def getOpParameters(self):
        """ Returns a variety of performance measurements.

            Useful for debugging."""
        self._op['avQueryDuration'] = 0
        if self._op['numQueries'] > 0:
            self._op['avQueryDuration'] = (
                    self._op['timeQueries'] / self._op['numQueries'])
        self._op['avCachePutDuration'] = 0
        if self._op['numCachePuts'] > 0:
            self._op['avCachePutDuration'] = (
                    self._op['timeCachePuts'] / self._op['numCachePuts'])
        self._op['avCacheGetDuration'] = 0
        if self._op['numCacheGets'] > 0:
            self._op['avCacheGetDuration'] = (
                    self._op['timeCacheGets'] / self._op['numCacheGets'])
        return self._op

    def setVerbose(self):
        """Sets Verbose to True"""
        self._vb = True

    def unsetVerbose(self):
        """Sets Verbose to False"""
        self._vb = False

    def cleanUp(self, cleanUpCache=True, doExit=False,
                exitMsg="Finished cleanUp, exiting"):
        """ Garbage collect queues, threads, and cache.

            By default, this wipes the cache. The idea being that if the
            entire attack finished successfully, then it won't be
            repeated and the cache isn't needed. Do `cleanUpCache=False`
            if that isn't what you want."""
        if self._vb: print(f"Calling {__name__}.cleanUp")
        if self._rawQ.empty() != True:
            print("Warning, trying to clean up when raw queue not empty!")
        if self._anonQ.empty() != True:
            print("Warning, trying to clean up when anon queue not empty!")
        if self.cacheQueue.empty() != True:
            print("Warning, trying to clean up when cache queue not empty!")
        # Stuff in end signals for the workers (this is a bit bogus, cause
        # if a thread is gone or hanging, not all signals will get read)
        for i in range(self._p['numRawDbThreads']):
            self._rawQ.put(None)
        for i in range(self._p['numAnonDbThreads']):
            self._anonQ.put(None)

        for i in range(self.cacheQueue.qsize()):
            self.cacheQueue.put(None)

        for t in self._rawThreads + self._anonThreads:
            if t.isAlive(): t.join()

        self.cacheThreadObject.terminate()

        if len(self._p['pubDb']) > 0:
            if self._pubQ.empty() != True:
                print("Warning, trying to clean up when pub queue not empty!")
            for i in range(self._p['numPubDbThreads']):
                self._pubQ.put(None)
            for t in self._pubThreads:
                if t.isAlive(): t.join()
        if cleanUpCache:
            self._removeLocalCacheDB()
        if doExit:
            sys.exit(exitMsg)

    def askClaim(self, spec, cache=True, claim=True):
        """Generate Claim query for raw and optionally pub databases.

        Making a claim results in a query to the raw database, and if
        linkability attack, the pub database, to check
        the correctness of the claim. Multiple calls to this method will
        cause the corresponding queries to be queued up, so `askClaim()`
        returns immediately. `getClaim()` harvests one claim result. <br/>
        Set `claim=False` if this claim should not be applied to the
        confidence improvement score. In this case, the probability score
        will instead be reduced accordingly. <br/>
        The `spec` is formatted as follows: <br/>

            {'known':[{'col':'colName','val':'value'},...],
              'guess':[{'col':'colName','val':'value'},...],
            }

        `spec['known']` are the columns and values the attacker already knows
        (i.e. with prior knowledge). Optional. <br/>
        `spec['guess']` are the columns and values the attacker doesn't know,
        but rather is trying to predict. Mandatory for 'singling out'
        and 'inference'. Optional for 'linkabiblity' <br/>
        Answers are cached <br/>
        Returns immediately"""
        if self._vb: print(f"Calling {__name__}.askClaim with spec '{spec}', count {self._claimCounter}")
        self._claimCounter += 1
        sql = self._makeSqlFromSpec(spec)
        if self._vb: print(f"Sql is '{sql}'")
        sqlConfs = self._makeSqlConfFromSpec(spec)
        if self._vb: print(f"SqlConf is '{sqlConfs}'")
        # Make a copy of the query for passing around
        job = {}
        job['q'] = self._claimQ
        job['claim'] = claim
        job['queries'] = [{'sql': sql, 'cache': cache}]
        job['spec'] = spec
        for sqlConf in sqlConfs:
            job['queries'].append({'sql': sqlConf, 'cache': cache})
        self._rawQ.put(job)

    def getClaim(self):
        """ Wait for and gather results of askClaim() calls

            Returns a data structure that contains both the result
            of one finished claim, and the claim's input parameters.
            Note that the order in which results are returned by
            `getClaim()` are not necessarily the same order they were
            inserted by `askClaim()`. <br/>
            Assuming `result` is returned: <br/>
            `result['claim']` is the value supplied in the corresponding
            `askClaim()` call <br/>
            `result['spec']` is a copy of the `spec` supplied in the
            corresponding `askClaim()` call. <br/>
            `result['queries']` is a list of the queries generated in order to
            validate the claim. <br/>
            `result['answers']` are the answers to the queries in
            `result['queries']`. <br/>
            `result['claimResult']` is 'Correct' or 'Incorrect', depending
            on whether the claim satisfies the critieria or not. <br/>
            `result['stillToCome']` is a counter showing how many more
            claims are still queued. When `stillToCome` is 0, then all
            claims submitted by `askClaim()` have been returned."""

        if self._vb:
            print(f"Calling {__name__}.getClaim")
        if self._claimCounter == 0:
            # Caller shouldn't be calling if there are no expected
            # answers, but is anyway, so just return
            return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                    'stillToCome': 0, 'claimResult': 'Error'}
        job = self._claimQ.get()
        claim = job['claim']
        self._claimQ.task_done()
        self._claimCounter -= 1
        job['stillToCome'] = self._claimCounter
        self._addToAtkRes('claimTrials', job['spec'], 1)
        # The claim is tested against the first reply
        reply = job['replies'][0]
        job['claimResult'] = 'Wrong'
        if claim:
            self._addToAtkRes('claimMade', job['spec'], 1)
        if 'error' in reply:
            self._addToAtkRes('claimError', job['spec'], 1)
            job['claimResult'] = 'Error'
        else:
            if self._cr == 'singlingOut':
                claimIsCorrect = self._checkSinglingOut(reply['answer'])
            elif self._cr == 'inference':
                claimIsCorrect = self._checkInference(reply['answer'])
            elif self._cr == 'linkability':
                claimIsCorrect = self._checkLinkability(reply['answer'])
            if claim == 1 and claimIsCorrect:
                self._addToAtkRes('claimCorrect', job['spec'], 1)
                job['claimResult'] = 'Correct'
            elif claim == 0 and claimIsCorrect:
                self._addToAtkRes('claimPassCorrect', job['spec'], 1)
                job['claimResult'] = 'Correct'
        if self._cr == 'singlingOut' or self._cr == 'inference':
            # Then measure confidence against the second and third replies
            if 'answer' in job['replies'][1]:
                if job['replies'][1]['answer']:
                    guessedRows = job['replies'][1]['answer'][0][0]
                else:
                    guessedRows = 0
            elif 'error' in job['replies'][1]:
                self._pp.pprint(job)
                print(f"Error: conf query:\n{job['replies'][1]['error']}")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if 'answer' in job['replies'][2]:
                if job['replies'][2]['answer']:
                    totalRows = job['replies'][2]['answer'][0][0]
                else:
                    totalRows = 0
            elif 'error' in job['replies'][2]:
                self._pp.pprint(job)
                print(f"Error: conf query:\n{job['replies'][2]['error']}")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if totalRows:
                self._addToAtkRes('sumConfidenceRatios', job['spec'],
                                  guessedRows / totalRows)
                self._addToAtkRes('numConfidenceRatios', job['spec'], 1)
                self._atrs['tableStats']['totalRows'] = totalRows
        else:
            # For linkability, the confidence is always 1/2
            self._addToAtkRes('sumConfidenceRatios', job['spec'], 0.5)
            self._addToAtkRes('numConfidenceRatios', job['spec'], 1)
        if 'q' in job:
            del job['q']
        return (job)

    def askAttack(self, query, cache=True):
        """ Generate and queue up an attack query for database.

            `query` is a dictionary with (currently) one value: <br/>
            `query['sql'] contains the SQL query."""
        self._attackCounter += 1
        if self._vb: print(f"Calling {__name__}.askAttack with query '{query}', count {self._attackCounter}")
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job['q'] = self._attackQ
        qCopy['cache'] = cache
        job['queries'] = [qCopy]
        self._anonQ.put(job)

    def getAttack(self):
        """ Returns the result of one askAttack() call

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askAttack()` calls were made. <br/>
            Assuming `result` is returned: <br/>
            `result['answer']` is the answer returned by the DB. The
            format is: <br/>
                `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` <br/>
            where C1 is the first element of the `SELECT`, C2 the second
            element, etc. <br/>
            `result['cells']` is the number of cells returned in the answer
            (used by `gdaAttack()` to compute total attack cells) <br/>
            `result['query']['sql']` is the query from the corresponding
            `askAttack()`."""

        if self._vb:
            print(f"Calling {__name__}.getAttack")
        if self._attackCounter == 0:
            # Caller shouldn't be calling if there are no expected
            # answers, but is anyway, so just return
            return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                    'stillToCome': 0}
        job = self._attackQ.get()
        self._attackQ.task_done()
        self._attackCounter -= 1
        reply = job['replies'][0]
        reply['stillToCome'] = self._attackCounter
        self._atrs['base']['attackGets'] += 1
        if 'cells' in reply:
            if reply['cells'] == 0:
                self._atrs['base']['attackCells'] += 1
            else:
                self._atrs['base']['attackCells'] += reply['cells']
        else:
            self._atrs['base']['attackCells'] += 1
        return (reply)

    def askKnowledge(self, query, cache=True):
        """ Generate and queue up a prior knowledge query for database

            The class keeps track of how many prior knowledge cells were
            returned and uses this to compute a score. <br/>
            Input parameters formatted the same as with `askAttack()`"""

        self._knowledgeCounter += 1
        if self._vb: print(f"Calling {__name__}.askKnowledge with query "
                           f"'{query}', count {self._knowledgeCounter}")
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job['q'] = self._knowledgeQ
        qCopy['cache'] = cache
        job['queries'] = [qCopy]
        self._rawQ.put(job)

    def getKnowledge(self):
        """ Wait for and gather results of prior askKnowledge() calls

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askKnowledge()` calls were made. <br/>
            Return parameter formatted the same as with `getAttack()`"""

        if self._vb:
            print(f"Calling {__name__}.getKnowledge")
        if self._knowledgeCounter == 0:
            # Caller shouldn't be calling if there are no expected
            # answers, but is anyway, so just return
            return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                    'stillToCome': 0}
        job = self._knowledgeQ.get()
        self._knowledgeQ.task_done()
        self._knowledgeCounter -= 1
        reply = job['replies'][0]
        reply['stillToCome'] = self._knowledgeCounter
        self._atrs['base']['knowledgeGets'] += 1
        if 'cells' in reply:
            self._atrs['base']['knowledgeCells'] += reply['cells']
        return (reply)

    def askExplore(self, query, cache=True):
        """ Generate and queue up an exploritory query for database

            No score book-keeping is done here. An analyst may make
            any number of queries without impacting the GDA score. <br/>
            `query` is a dictionary with two values: <br/>
            `query['sql']` contains the SQL query. <br/>
            `query['db']` determines which database is queried, and
            is one of 'rawDb', 'anonDb', or (if linkability), 'pubDb'."""

        self._exploreCounter += 1
        if self._vb: print(f"Calling {__name__}.askExplore with "
                           f"query '{query}', count {self._exploreCounter}")
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job['q'] = self._exploreQ
        qCopy['cache'] = cache
        job['queries'] = [qCopy]
        if qCopy['db'] == 'rawDb' or qCopy['db'] == 'raw':
            self._rawQ.put(job)
        elif qCopy['db'] == 'anonDb' or qCopy['db'] == 'anon':
            self._anonQ.put(job)
        else:
            self._pubQ.put(job)

    def getExplore(self):
        """ Wait for and gather results of prior askExplore() calls.

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askExplore()` calls were made. <br/>
            Return parameter formatted the same as with `getAttack()`"""
        if self._vb:
            print(f"Calling {__name__}.getExplore")
        if self._exploreCounter == 0:
            # Caller shouldn't be calling if there are no expected
            # answers, but is anyway, so just return
            return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                    'stillToCome': 0}
        job = self._exploreQ.get()
        self._exploreQ.task_done()
        self._exploreCounter -= 1
        reply = job['replies'][0]
        reply['stillToCome'] = self._exploreCounter
        return (reply)

    def getPublicColValues(self, colName, tableName=''):
        """Return list of "publicly known" column values and counts

        Column value has index 0, count of distinct UIDs has index 1
        Must specify column name.
        """
        if len(colName) == 0:
            print(f"Must specify column 'colName'")
            return None

        if len(tableName) == 0:
            # caller didn't supply a table name, so get it from the
            # class init
            tableName = self._p['table']

        # Establish connection to database
        db = getDatabaseInfo(self._p['rawDb'])
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # First we need to know the total number of distinct users
        sql = str(f"""select count(distinct {self._p['uid']})
                      from {tableName}""")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getPublicColValues() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        numUid = ans[0][0]
        # Query the raw db for values in the column
        sql = str(f"""select {colName}, count(distinct {self._p['uid']})
                      from {tableName}
                      group by 1
                      order by 2 desc
                      limit 200""")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getPublicColValues() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            # row[0] is the value, row[1] is the count
            if (((row[1] / numUid) > 0.002) and
                    (row[1] >= 50)):
                ret.append((row[0], row[1]))
        conn.close()
        return ret

    def getColNames(self, dbType='rawDb', tableName=''):
        """Return simple list of column names

        `dbType` is one of 'rawDb' or 'anonDb'"""

        if len(tableName) == 0:
            colsAndTypes = self.getColNamesAndTypes(dbType=dbType)
        else:
            colsAndTypes = self.getColNamesAndTypes(
                dbType=dbType, tableName=tableName)
        if not colsAndTypes:
            return None
        cols = []
        for tup in colsAndTypes:
            cols.append(tup[0])
        return cols

    def getAttackTableName(self):
        """Returns the name of the table being used in the attack."""
        return self._p['table']

    def getTableCharacteristics(self, tableName=''):
        """Returns the full contents of the table characteristics

           Return value is a dict indexed by column name: <br/>

               { '<colName>':
                   {
                       'av_rows_per_vals': 3.93149,
                       'av_uids_per_val': 0.468698,
                       'column_label': 'continuous',
                       'column_name': 'dropoff_latitude',
                       'column_type': 'real',
                       'max': '898.29382000000000',
                       'min': '-0.56333297000000',
                       'num_distinct_vals': 24216,
                       'num_rows': 95205,
                       'num_uids': 11350,
                       'std_rows_per_val': 10.8547,
                       'std_uids_per_val': 4.09688},
                   }
               }

        """
        if len(tableName) == 0:
            # caller didn't supply a table name, so get it from the
            # class init
            tableName = self._p['table']

        # Modify table name to the default for the characteristics table
        tableName += '_char'

        # Establish connection to database
        db = getDatabaseInfo(self._p['rawDb'])
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Set up return dict
        ret = {}
        # Query it for column names
        sql = str(f"""select column_name, data_type 
                  from information_schema.columns where
                  table_name='{tableName}'""")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getTableCharacteristics() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        cols = cur.fetchall()
        # Make index for column name (should be 0, but just to be sure)
        for colNameIndex in range(len(cols)):
            if cols[colNameIndex][0] == 'column_name':
                break

        # Query it for table contents
        sql = str(f"SELECT * FROM {tableName}")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getTableCharacteristics() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        for row in ans:
            colName = row[colNameIndex]
            ret[colName] = {}
            for i in range(len(row)):
                ret[colName][cols[i][0]] = row[i]
        conn.close()
        return ret

    # Note that following is used internally, but we expose it to the
    # caller as well because it is a useful function for exploration
    def getColNamesAndTypes(self, dbType='rawDb', tableName=''):
        """Return raw database column names and types (or None if error)

        dbType is one of 'rawDb' or 'anonDb' <br/>
        return format: [(col,type),(col,type),...]"""
        if len(tableName) == 0:
            # caller didn't supply a table name, so get it from the
            # class init
            tableName = self._p['table']

        # Establish connection to database
        db = getDatabaseInfo(self._p[dbType])
        if db['type'] != 'postgres' and db['type'] != 'aircloak':
            print(f"DB type '{db['type']}' must be 'postgres' or 'aircloak'")
            return None
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Query it for column names
        if db['type'] == 'postgres':
            sql = str(f"""select column_name, data_type 
                      from information_schema.columns where
                      table_name='{tableName}'""")
        elif db['type'] == 'aircloak':
            sql = str(f"show columns from {tableName}")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getColNamesAndTypes() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            ret.append((row[0], row[1]))
        conn.close()
        return ret

    def getTableNames(self, dbType='rawDb'):
        """Return database table names

        dbType is one of 'rawDb' or 'anonDb' <br/>
        Table names returned as list, unless error then return None"""

        # Establish connection to database
        db = getDatabaseInfo(self._p[dbType])
        if db['type'] != 'postgres' and db['type'] != 'aircloak':
            print(f"DB type '{db['type']}' must be 'postgres' or 'aircloak'")
            return None
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Query it for column names
        if db['type'] == 'postgres':
            sql = """SELECT tablename
                     FROM pg_catalog.pg_tables
                     WHERE schemaname != 'pg_catalog' AND
                           schemaname != 'information_schema'"""
        elif db['type'] == 'aircloak':
            sql = "show tables"
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getTableNames() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            ret.append(row[0])
        conn.close()
        return ret

    def getUidColName(self):
        """ Returns the name of the UID column"""
        return self._p['uid']

    def getPriorKnowledge(self, dataColumns, method,
            fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):
        """ Returns data from the rawDB according to a specification

        This mimics external knowledge that an attacker may have about the data, and
        influences the 'knowledge' part of the GDA Score. <br/>
            `dataColumns` is a list of column names. The data for these columns is returned <br/>
            `method` can be 'rows' or 'users'. If 'rows', then rows are selected
            according to the criteria (`fraction`, `count`, `selectColumn`, `colRange`,
            or `values`).
            If 'users', then all rows for a set of selected users is returned.
            The users are selected according to the criteria (`fraction` or `count`) <br/>
            If none of the criteria are set, or if `fraction` is set to 1.0, then all
            rows are returned (for the selected column values) One of `fraction`, `count`,
            or `selectColumn` must be set. <br/>
            `fraction` or `count` are set to obtain a random set of rows or users. If
            `fraction`, then an approximate fraction of all rows/users is selected.
            `fraction` is a value between 0 and 1.0. If `count`, then exactly `count`
            random rows/users are selected. <br/>
            `selectColumn` is set to select rows according to the values of the specified
            column. `selectColumn` is a column name. If set, then either a range of
            values (`colRange`), or a set of values (`values`) must be chosen. <br/>
            `colRange` is
            a list with two numeric or datetime values: `[min,max]`. This selects all values
            between min and max inclusive. <br/>
            `values` is a list
            of one or more values of any type. This selects all values matching those in
            the list. <br/>
            The return value is a list in this format: <br/>
                `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` <br/>
            where C1 corresponds to the first column in `dataColumns`, C2 corresponds to
            the second column in `dataColumns`, and so on.  <br/>
        """
        # Check input parameters
        if not isinstance(dataColumns, list):
            print(f"getPriorKnowledge Error: dataColumns must be a list of one or more column names")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if method not in ['rows','users']:
            print(f"getPriorKnowledge Error: method must be 'rows' or 'users'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if fraction is None and count is None and selectColumn is None:
            print(f"getPriorKnowledge Error: one of fraction, count, or selectColumn must be set")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if fraction and not isinstance(fraction, float):
            print(f"getPriorKnowledge Error: if set, fraction must be a float")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if (fraction and (count or selectColumn)) or (count and (fraction or selectColumn)):
            print(f"getPriorKnowledge Error: only one of fraction, count, or selectColumn may be set")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if count and not isinstance(count, int):
            print(f"getPriorKnowledge Error: if set, count must be an integer")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if selectColumn: 
            if selectColumn not in self._colNames:
                print(f"getPriorKnowledge Error: selectColumn '{selectColumn}' is not a valid column")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if colRange == [None,None] and values == [None]:
                print(f"getPriorKnowledge Error: if selectColumn is set, one of colRange or values must be set")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if not isinstance(colRange, list):
                print(f"getPriorKnowledge Error: colRange must be a list with two values")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if not isinstance(values, list) or len(values) == 0:
                print(f"getPriorKnowledge Error: values must be a list with one or more values")
                self.cleanUp(cleanUpCache=False, doExit=True)
        for col in dataColumns:
            if col not in self._colNames:
                print(f"getPriorKnowledge Error: column '{col}' is not a valid column")
                self.cleanUp(cleanUpCache=False, doExit=True)
        # Basic input checks finished
        # Establish connection to database
        db = getDatabaseInfo(self._p['rawDb'])
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        table = self._p['table']
        uid = self._p['uid']
        # Make the SELECT part of the SQL query
        initSql = 'SELECT '
        for col in dataColumns:
            initSql += str(f"{col}, ")
        initSql = initSql[0:-2]
        if method == 'rows' and fraction:
            sql = initSql + str(f" FROM {table} WHERE random() <= {fraction}")
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'users' and fraction:
            sql = initSql + str(f" FROM {table} WHERE {uid} IN ")
            sql += str(f"(SELECT {uid} from (SELECT DISTINCT {uid} FROM {table}) t WHERE random() < {fraction})")
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'rows' and colRange[0] is not None:
            sql = initSql + str(f" FROM {table} WHERE {selectColumn} >= {colRange[0]} and {selectColumn} <= {colRange[1]}")
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'rows' and values[0] is not None:
            sql = initSql + str(f" FROM {table} WHERE {selectColumn} IN (")
            for pair in self._colNamesTypes:
                if selectColumn in pair[0]:
                    colType = pair[1]
                    break
            for value in values:
                if "text" in colType or "date" in colType or "time" in colType:
                    sql += str(f"'{value}', ")
                else:
                    sql += str(f"{value}, ")
            sql = sql[0:-2]
            sql += ")"
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'rows' and count:
            # need to know the total number of rows
            sql = str(f"select count(*) from {table}")
            ans = self._doQuery(cur,sql)
            numRows = ans[0][0]
            # next we get some random set of rows that is certainly more than we need
            frac = (count/numRows)*2
            sql = initSql + str(f" FROM {table} WHERE random() <= {frac}")
            temp = self._doQuery(cur,sql)
            # next we scramble these so that we get a random sampling from the random sampling
            random.shuffle(temp)
            # finally pick the exact count
            ans = temp[0:count]
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'users' and count:
            # get the full list of distinct UIDs
            sql = str(f"SELECT DISTINCT {uid} from {table}")
            uidList = self._doQuery(cur,sql)
            # next we scramble these so that we can get a random sampling
            random.shuffle(uidList)
            # pick the exact count of UIDs
            uidList = uidList[0:count]
            sql = initSql + str(f" FROM {table} WHERE {uid} IN (")
            for pair in self._colNamesTypes:
                if uid in pair[0]:
                    colType = pair[1]
                    break
            for uidVal in uidList:
                if "text" in colType or "date" in colType or "time" in colType:
                    sql += str(f"'{uidVal[0]}', ")
                else:
                    sql += str(f"{uidVal[0]}, ")
            sql = sql[0:-2]
            sql += ")"
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        #zzzz
        return None
    #def getPriorKnowledge(self, dataColumns, method,
            #fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):

    # -------------- Private Methods -------------------
    def _doQuery(self,cur,sql):
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getPublicColValues() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        return ans

    def _cleanPasswords(self):
        if 'attack' in self._atrs:
            if ('anonDb' in self._atrs['attack'] and
                    'password' in self._atrs['attack']['anonDb']):
                self._atrs['attack']['anonDb']['password'] = 'xxxxxxx'
            if ('rawDb' in self._atrs['attack'] and
                    'password' in self._atrs['attack']['rawDb']):
                self._atrs['attack']['rawDb']['password'] = 'xxxxxxx'
            if ('pubDb' in self._atrs['attack'] and
                    'password' in self._atrs['attack']['pubDb']):
                self._atrs['attack']['pubDb']['password'] = 'xxxxxxx'

        return

    def _assignGlobalParams(self, params):
        self._pp = pprint.PrettyPrinter(indent=4)
        for key, val in params.items():
            self._p[key] = val
            # assign verbose value to a smaller variable name
            if key == "verbose":
                if val != False:
                    self._vb = True
            # Check criteria
            if key == "criteria":
                if (val == 'singlingOut' or val == 'inference' or
                        val == 'linkability'):
                    self._cr = val
                else:
                    print("""Error: criteria must be one of 'singlingOut',
                             'inference', or 'linkability'""")
                    sys.exit('')

    def _setupLocalCacheDB(self):
        path = self._p['locCacheDir'] + "/" + self._p['name'] + ".db"
        conn = sqlite3.connect(path)
        cur = conn.cursor()
        if self._p['flushCache'] == True:
            sql = "DROP TABLE IF EXISTS tab"
            if self._vb: print(f"   cache DB: {sql}")
            cur.execute(sql)
        sql = """CREATE TABLE IF NOT EXISTS tab
                 (qid text, answer text)"""
        if self._vb: print(f"   cache DB: {sql}")
        cur.execute(sql)
        conn.close()

    def _removeLocalCacheDB(self):
        path = self._p['locCacheDir'] + "/" + self._p['name'] + ".db"
        if os.path.exists(path):
            try:
                os.remove(path)
            except Exception as ex:
                print(f"ERROR: Failed to remove cache DB {path} => ex: {ex}")

    def _setupThreadsAndQueues(self):
        self._anonThreads = []
        self._rawThreads = []
        self._pubThreads = []
        self._exploreQ = queue.Queue()
        self._knowledgeQ = queue.Queue()
        self._attackQ = queue.Queue()
        self._claimQ = queue.Queue()
        self._guessQ = queue.Queue()
        self._rawQ = queue.Queue()
        if self._cr == 'linkability':
            self._pubQ = queue.Queue()
        self._anonQ = queue.Queue()
        backQ = queue.Queue()
        for i in range(self._p['numRawDbThreads']):
            d = dict(db=self._p['rawDb'], q=self._rawQ,
                     kind='raw', backQ=backQ)
            t = EnhancedThread(target=self._dbWorker, kwargs=d)
            t.start()
            self._rawThreads.append(t)
        for i in range(self._p['numAnonDbThreads']):
            d = dict(db=self._p['anonDb'], q=self._anonQ,
                     kind='anon', backQ=backQ)
            t = EnhancedThread(target=self._dbWorker, kwargs=d)
            t.start()
            self._anonThreads.append(t)
        if self._cr == 'linkability':
            for i in range(self._p['numPubDbThreads']):
                d = dict(db=self._p['pubDb'], q=self._pubQ,
                         kind='pub', backQ=backQ)
                t = EnhancedThread(target=self._dbWorker, kwargs=d)
                t.start()
                self._pubThreads.append(t)
        num = (self._p['numRawDbThreads'] + self._p['numAnonDbThreads'])
        if self._cr == 'linkability':
            num += self._p['numPubDbThreads']
        # Make sure all the worker threads are ready
        for i in range(num):
            msg = backQ.get()
            if self._vb: print(f"{msg} is ready")
            backQ.task_done()

    def _dbWorker(self, db, q, kind, backQ):
        if self._vb: print(f"Starting {__name__}.dbWorker:{db, kind}")
        me = threading.current_thread()
        d = getDatabaseInfo(db)
        # Establish connection to database
        connStr = str(
            f"host={d['host']} port={d['port']} dbname={d['dbname']} user={d['user']} password={d['password']}")
        if self._vb: print(f"    {me}: Connect to DB with DSN '{connStr}'")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Establish connection to local cache
        path = self._p['locCacheDir'] + "/" + self._p['name'] + ".db"
        # Set timeout low so that we don't spend a lot of time inserting
        # into the cache in case it gets overloaded
        connInsert = sqlite3.connect(path, timeout=0.1)
        curInsert = connInsert.cursor()
        connRead = sqlite3.connect(path)
        curRead = connRead.cursor()
        backQ.put(me)
        while True:
            jobOrig = q.get()
            q.task_done()
            if jobOrig is None:
                if self._vb: print(f"    {me}: dbWorker done {db, kind}")
                conn.close()
                connRead.close()
                connInsert.close()
                break
            # make a copy for passing around
            job = copy.copy(jobOrig)
            replyQ = job['q']
            replies = []
            for query in job['queries']:
                reply = self._processQuery(query, conn, cur,
                                           connInsert, curInsert, curRead)
                replies.append(reply)
            job['replies'] = replies
            replyQ.put(job)

    def _processQuery(self, query, conn, cur, connInsert, curInsert, curRead):
        # record and remove the return queue
        cache = query['cache']
        del query['cache']
        # Check the cache for the answer
        # Note that at this point query is a dict
        # containing the sql, the db (raw, anon, or pub),
        # and any tags that the source added
        cachedReply = None
        if cache:
            cachedReply = self._getCache(curRead, query)
        if cachedReply:
            if self._vb: print("    Answer from cache")
            if 'answer' in cachedReply:
                numCells = self._computeNumCells(cachedReply['answer'])
                cachedReply['cells'] = numCells
            return cachedReply
        else:
            start = time.perf_counter()
            try:
                cur.execute(query['sql'])
            except psycopg2.Error as e:
                reply = dict(error=e.pgerror)
            else:
                ans = cur.fetchall()
                numCells = self._computeNumCells(ans)
                reply = dict(answer=ans, cells=numCells)
            end = time.perf_counter()
            duration = end - start
            self._op['numQueries'] += 1
            self._op['timeQueries'] += duration
            reply['query'] = query
            # only cache if the native query is slow
            if duration > 0.1:
                # self._putCache(connInsert, curInsert, query, reply)
                self.cacheQueue.put([connInsert, curInsert, query, reply])
            return reply

    def _checkInference(self, ans):
        # column 0 must be UID
        # User is inferred if all users in answer have same attributes
        # Returns 1 if inference claim correct, else returns 0
        if len(ans) == 0:
            return 0
        numRows = len(ans)
        numColumns = len(ans[0])
        if numColumns < 2:
            # Can't test inference unless there is at least one column
            # (other than UID) that is the same
            return 0
        for c in range(1, numColumns):
            val = ans[0][c]
            for r in range(1, numRows):
                if val != ans[r][c]:
                    return 0
        return 1

    def _checkLinkability(self, ans):
        # The test is the same as with singling out
        # Returns 1 if linkability claim correct, else returns 0
        return self._checkSinglingOut(ans)

    def _checkSinglingOut(self, ans):
        # column 0 must be UID
        # User is singled-out if there is only one distinct UID
        # Returns 1 if singling out claim correct, else returns 0
        if len(ans) == 0:
            return 0
        uids = {}
        for row in ans:
            uids[row[0]] = 1
        numUids = len(uids)
        if numUids == 1:
            return 1
        else:
            return 0

    def _computeNumCells(self, ans):
        # ans is a list of tuples [(x,y),(x,y),(x,y) ...
        # Count the number of columns (in the first row)
        if len(ans) == 0:
            return 0
        numColumns = len(ans[0])
        numRows = len(ans)
        numCells = numColumns * numRows
        return numCells

    def _doParamChecks(self):
        dbInfoRaw = getDatabaseInfo(self._p['rawDb'])
        if not dbInfoRaw:
            sys.exit('rawDb now found in database config')
        if len(self._p['anonDb']) == 0:
            self._p['anonDb'] = self._p['rawDb']
        else:
            dbInfoAnon = getDatabaseInfo(self._p['anonDb'])
            if not dbInfoAnon:
                sys.exit('anonDb not found in database config')
        if self._cr == 'linkability':
            dbInfo = getDatabaseInfo(self._p['pubDb'])
            if not dbInfo:
                sys.exit('Must specify pubDb if criteria is linkability')
        numThreads = self._p['numRawDbThreads'] + self._p['numAnonDbThreads']
        if self._cr == 'linkability':
            numThreads += self._p['numPubDbThreads']
        if numThreads > 50:
            sys.exit("Error: Can't have more than 50 threads total")

    def _getCache(self, cur, query):
        # turn the query (dict) into a string
        qStr = self._dict2Str(query)
        if qStr is None:
            return None
        sql = str(f"SELECT answer FROM tab where qid = '{qStr}'")
        if self._vb: print(f"   cache DB: {sql}")
        start = time.perf_counter()
        try:
            cur.execute(sql)
        except sqlite3.Error as e:
            print(f"getCache error '{e.args[0]}'")
            return None
        end = time.perf_counter()
        self._op['numCacheGets'] += 1
        self._op['timeCacheGets'] += (end - start)
        answer = cur.fetchone()
        if not answer:
            return None
        rtnDict = self._str2Dict(answer[0])
        return rtnDict

    def _putCache(self, conn, cur, query, reply):
        # turn the query and reply (dict) into a string
        qStr = self._dict2Str(query)
        if qStr is None:
            return
        rStr = self._dict2Str(reply)
        if rStr is None:
            return
        sql = str(f"INSERT INTO tab VALUES ('{qStr}','{rStr}')")
        if self._vb: print(f"   cache DB: {sql}")
        start = time.perf_counter()
        err = None
        for z in range(10):
            try:
                cur.execute(sql)
                conn.commit()
            except sqlite3.OperationalError as e:
                if self._p['verbose'] or self._vb:
                    print(f"putCache error '{e.args[0]}'")
                err = e
                continue
            except sqlite3.Error as e:
                if self._p['verbose'] or self._vb:
                    print(f"putCache error '{e.args[0]}'")
                err = e
                continue
            else:
                break
        else:
            # raise err
            if self._p['verbose'] or self._vb:
                print(f'>> could not insert into cache DB >> ERROR: {err}')

        end = time.perf_counter()
        self._op['numCachePuts'] += 1
        self._op['timeCachePuts'] += (end - start)

    def putCacheWrapper(self, conn, cur, query, reply):
        self._putCache(conn, cur, query, reply)

    def _dict2Str(self, d):
        try:
            dStr = simplejson.dumps(d)
        except TypeError:
            print("simpleJson failed")
            return None
        dByte = str.encode(dStr)
        dByte64 = base64.b64encode(dByte)
        try:
            dByte64Str = str(dByte64, "utf-8")
        except MemoryError:
            print("str(dByte64) failed")
            return None
        return dByte64Str

    def _str2Dict(self, dByte64Str):
        dByte64 = str.encode(dByte64Str)
        dByte = base64.b64decode(dByte64)
        dStr = str(dByte, "utf-8")
        d = simplejson.loads(dStr)
        return d

    def _makeSqlFromSpec(self, spec):
        sql = "select "
        if 'known' in spec:
            numKnown = len(spec['known'])
        else:
            numKnown = 0
        if 'guess' in spec:
            numGuess = len(spec['guess'])
        else:
            numGuess = 0
        if self._cr == 'inference':
            sql += str(f"{self._p['uid']}, ")
            for i in range(numGuess):
                sql += str(f"{spec['guess'][i]['col']}")
                if i == (numGuess - 1):
                    sql += " "
                else:
                    sql += ", "
            sql += str(f"from {self._p['table']} ")
            if numKnown:
                sql += "where "
            for i in range(numKnown):
                sql += str(f"{spec['known'][i]['col']} = ")
                sql += str(f"'{spec['known'][i]['val']}' ")
                if i == (numKnown - 1):
                    sql += " "
                else:
                    sql += "and "
        elif self._cr == 'singlingOut' or self._cr == 'linkability':
            sql += str(f"{self._p['uid']} from {self._p['table']} where ")
            for i in range(numKnown):
                sql += str(f"{spec['known'][i]['col']} = ")
                sql += str(f"'{spec['known'][i]['val']}' and ")
            for i in range(numGuess):
                sql += str(f"{spec['guess'][i]['col']} = ")
                sql += str(f"'{spec['guess'][i]['val']}' ")
                if i == (numGuess - 1):
                    sql += " "
                else:
                    sql += "and "
        return sql

    def _makeSqlConfFromSpec(self, spec):
        sqls = []
        numGuess = len(spec['guess'])
        if self._cr == 'inference' or self._cr == 'singlingOut':
            sql = str(f"select count(*) from {self._p['table']} where ")
            # This first sql learns the number of rows matching the
            # guessed values
            for i in range(numGuess):
                sql += str(f"{spec['guess'][i]['col']} = ")
                sql += str(f"'{spec['guess'][i]['val']}'")
                if i != (numGuess - 1):
                    sql += " and "
            sqls.append(sql)
            # This second sql learns the total number of rows (should
            # normally be a cached result)
            sql = str(f"select count(*) from {self._p['table']}")
            sqls.append(sql)
        elif self._cr == 'linkability':
            # nothing happens for linkability
            pass
        return sqls

    def _addToAtkRes(self, label, spec, val):
        """Adds the value to each column in the guess"""
        for tup in spec['guess']:
            col = tup['col']
            if col not in self._atrs['col']:
                print(f"Error: addToAtkRes(): Bad column in spec: '{col}'")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if label not in self._atrs['col'][col]:
                print(f"Error: addToAtkRes(): Bad label '{label}'")
                self.cleanUp(cleanUpCache=False, doExit=True)
            self._atrs['col'][col][label] += val

    def _initAtkRes(self):
        self._atrs = {}
        self._atrs['attack'] = {}
        self._atrs['base'] = {}
        self._atrs['tableStats'] = {}
        self._atrs['col'] = {}
        # ----- Attack parameters
        self._atrs['attack']['attackName'] = self._p['name']
        self._atrs['attack']['rawDb'] = self._p['rawDb']
        self._atrs['attack']['anonDb'] = self._p['anonDb']
        if self._cr == 'linkability':
            self._atrs['attack']['pubDb'] = self._p['anonDb']
        self._atrs['attack']['criteria'] = self._p['criteria']
        self._atrs['attack']['table'] = self._p['table']
        # add parameters for the database machine itself
        db = getDatabaseInfo(self._p['rawDb'])
        self._atrs['attack']['rawHost'] = db['host']
        self._atrs['attack']['rawDbName'] = db['dbname']
        self._atrs['attack']['rawPort'] = db['port']
        if self._cr == 'linkability':
            db = getDatabaseInfo(self._p['pubDb'])
            self._atrs['attack']['pubHost'] = db['host']
            self._atrs['attack']['pubDbName'] = db['dbname']
            self._atrs['attack']['pubPort'] = db['port']
        db = getDatabaseInfo(self._p['anonDb'])
        self._atrs['attack']['anonHost'] = db['host']
        self._atrs['attack']['anonDbName'] = db['dbname']
        self._atrs['attack']['anonPort'] = db['port']
        # and a timestamp
        self._atrs['attack']['startTime'] = str(datetime.datetime.now())
        # ----- Params for computing knowledge:
        # number of prior knowledge cells requested
        self._atrs['base']['knowledgeCells'] = 0
        # number of times knowledge was queried
        self._atrs['base']['knowledgeGets'] = 0

        # ----- Params for computing how much work needed to attack:
        # number of attack cells requested
        self._atrs['base']['attackCells'] = 0
        # number of times attack was queried
        self._atrs['base']['attackGets'] = 0
        self._atrs['tableStats']['colNamesAndTypes'] = self._colNamesTypes
        self._atrs['tableStats']['numColumns'] = len(self._colNamesTypes)
        for tup in self._colNamesTypes:
            col = tup[0]
            if self._vb: print(f"initAtkRes() init column '{col}'")
            self._atrs['col'][col] = {}

            # ----- Params for computing claim success rate:
            # total possible number of claims
            self._atrs['col'][col]['claimTrials'] = 0
            # actual number of claims
            self._atrs['col'][col]['claimMade'] = 0
            # number of correct claims
            self._atrs['col'][col]['claimCorrect'] = 0
            # number of claims that produced bad SQL answer
            self._atrs['col'][col]['claimError'] = 0
            # claims where the attacker chose to pass (not make a claim),
            # but where the claim would have been correct
            self._atrs['col'][col]['claimPassCorrect'] = 0

            # ----- Params for computing confidence:
            # sum of all known count to full count ratios
            self._atrs['col'][col]['sumConfidenceRatios'] = 0
            # number of such ratios
            self._atrs['col'][col]['numConfidenceRatios'] = 0
            # average confidence ratio (division of above two params)
            self._atrs['col'][col]['avgConfidenceRatios'] = 0

    def _initOp(self):
        self._op['numQueries'] = 0
        self._op['timeQueries'] = 0
        self._op['numCachePuts'] = 0
        self._op['timeCachePuts'] = 0
        self._op['numCacheGets'] = 0
        self._op['timeCacheGets'] = 0

    def _initCounters(self):
        self._exploreCounter = 0
        self._knowledgeCounter = 0
        self._attackCounter = 0
        self._claimCounter = 0
        self._guessCounter = 0

    def __del__(self):
        self.cacheThreadObject.terminate()


class EnhancedThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__kill_received = False
        self.daemon = True

    @property
    def signalKill(self):
        return self.__kill_received

    def terminate(self):
        self.__kill_received = True
        if self.isAlive():
            self.join(timeout=0.1)


class CacheThread(EnhancedThread):
    def __init__(self, theQueue, atcObject):
        super().__init__()
        self.theQueue = theQueue
        self.atcObject = atcObject

    def run(self):
        while not super().signalKill:
            if not self.theQueue.empty():
                data = self.theQueue.get()
                self.atcObject.putCacheWrapper(*data)
                if self.atcObject._p['verbose'] or self.atcObject._vb:
                    printTitle('cache insert successful. queue length: ' + str(self.theQueue.qsize()))


def printTitle(text):
    text = " " + text + " "
    print(f'\n{text:#^100}\n')

signal_kill_received = False

def signal_kill_handler(signum, frame):
    global signal_kill_received
    signal_kill_received = True

    printTitle("Terminating the program ...")
    print(
        f' > active background threads: {threading.active_count() - 1} | sending termination signal to all. please wait ...\n')
    for item in threading.enumerate():
        if item != threading.current_thread() and isinstance(item, EnhancedThread):
            item.terminate()
            print(f' > {item.getName()} sent.')
    printTitle('All done!')

    sys.exit(0)


def on_exit():
    if not signal_kill_received:
        printTitle('Main program finished successfully. Threads in background are running...')
        if threading.active_count() > 1:
            for t in threading.enumerate():
                if t != threading.main_thread():
                    t.join()
        printTitle("Whole execution process finished successfully.")


signal.signal(signal.SIGTERM, signal_kill_handler)
signal.signal(signal.SIGINT, signal_kill_handler)

atexit.register(on_exit)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="gdaAttack.flgCacheThreadStarted" class="name">var <span class="ident">flgCacheThreadStarted</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="gdaAttack.signal_kill_received" class="name">var <span class="ident">signal_kill_received</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="gdaAttack.theCacheQueue" class="name">var <span class="ident">theCacheQueue</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="gdaAttack.theCacheThreadObject" class="name">var <span class="ident">theCacheThreadObject</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="gdaAttack.on_exit">
    <p>def <span class="ident">on_exit</span>(</p><p>)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.on_exit', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.on_exit" class="source">
    <pre><code>def on_exit():
    if not signal_kill_received:
        printTitle('Main program finished successfully. Threads in background are running...')
        if threading.active_count() > 1:
            for t in threading.enumerate():
                if t != threading.main_thread():
                    t.join()
        printTitle("Whole execution process finished successfully.")
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="gdaAttack.printTitle">
    <p>def <span class="ident">printTitle</span>(</p><p>text)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.printTitle', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.printTitle" class="source">
    <pre><code>def printTitle(text):
    text = " " + text + " "
    print(f'\n{text:#^100}\n')
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="gdaAttack.signal_kill_handler">
    <p>def <span class="ident">signal_kill_handler</span>(</p><p>signum, frame)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.signal_kill_handler', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.signal_kill_handler" class="source">
    <pre><code>def signal_kill_handler(signum, frame):
    global signal_kill_received
    signal_kill_received = True

    printTitle("Terminating the program ...")
    print(
        f' > active background threads: {threading.active_count() - 1} | sending termination signal to all. please wait ...\n')
    for item in threading.enumerate():
        if item != threading.current_thread() and isinstance(item, EnhancedThread):
            item.terminate()
            print(f' > {item.getName()} sent.')
    printTitle('All done!')

    sys.exit(0)
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="gdaAttack.CacheThread" class="name">class <span class="ident">CacheThread</span></p>
      
  
    <div class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread" class="source">
    <pre><code>class CacheThread(EnhancedThread):
    def __init__(self, theQueue, atcObject):
        super().__init__()
        self.theQueue = theQueue
        self.atcObject = atcObject

    def run(self):
        while not super().signalKill:
            if not self.theQueue.empty():
                data = self.theQueue.get()
                self.atcObject.putCacheWrapper(*data)
                if self.atcObject._p['verbose'] or self.atcObject._vb:
                    printTitle('cache insert successful. queue length: ' + str(self.theQueue.qsize()))
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#gdaAttack.CacheThread">CacheThread</a></li>
          <li><a href="#gdaAttack.EnhancedThread">EnhancedThread</a></li>
          <li>threading.Thread</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, theQueue, atcObject)</p>
    </div>
    

    
  
    <div class="desc"><p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.__init__', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.__init__" class="source">
    <pre><code>def __init__(self, theQueue, atcObject):
    super().__init__()
    self.theQueue = theQueue
    self.atcObject = atcObject
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.getName">
    <p>def <span class="ident">getName</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.getName', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.getName" class="source">
    <pre><code>def getName(self):
    return self.name
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.isAlive">
    <p>def <span class="ident">isAlive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just
after the run() method terminates. The module function enumerate()
returns a list of all alive threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.isAlive', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.isAlive" class="source">
    <pre><code>def is_alive(self):
    """Return whether the thread is alive.
    This method returns True just before the run() method starts until just
    after the run() method terminates. The module function enumerate()
    returns a list of all alive threads.
    """
    assert self._initialized, "Thread.__init__() not called"
    if self._is_stopped or not self._started.is_set():
        return False
    self._wait_for_tstate_lock(False)
    return not self._is_stopped
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.isDaemon">
    <p>def <span class="ident">isDaemon</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.isDaemon', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.isDaemon" class="source">
    <pre><code>def isDaemon(self):
    return self.daemon
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.is_alive">
    <p>def <span class="ident">is_alive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just
after the run() method terminates. The module function enumerate()
returns a list of all alive threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.is_alive', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.is_alive" class="source">
    <pre><code>def is_alive(self):
    """Return whether the thread is alive.
    This method returns True just before the run() method starts until just
    after the run() method terminates. The module function enumerate()
    returns a list of all alive threads.
    """
    assert self._initialized, "Thread.__init__() not called"
    if self._is_stopped or not self._started.is_set():
        return False
    self._wait_for_tstate_lock(False)
    return not self._is_stopped
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.join">
    <p>def <span class="ident">join</span>(</p><p>self, timeout=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait until the thread terminates.</p>
<p>This blocks the calling thread until the thread whose join() method is
called terminates -- either normally or through an unhandled exception
or until the optional timeout occurs.</p>
<p>When the timeout argument is present and not None, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof). As join() always returns None, you must call
isAlive() after join() to decide whether a timeout happened -- if the
thread is still alive, the join() call timed out.</p>
<p>When the timeout argument is not present or None, the operation will
block until the thread terminates.</p>
<p>A thread can be join()ed many times.</p>
<p>join() raises a RuntimeError if an attempt is made to join the current
thread as that would cause a deadlock. It is also an error to join() a
thread before it has been started and attempts to do so raises the same
exception.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.join', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.join" class="source">
    <pre><code>def join(self, timeout=None):
    """Wait until the thread terminates.
    This blocks the calling thread until the thread whose join() method is
    called terminates -- either normally or through an unhandled exception
    or until the optional timeout occurs.
    When the timeout argument is present and not None, it should be a
    floating point number specifying a timeout for the operation in seconds
    (or fractions thereof). As join() always returns None, you must call
    isAlive() after join() to decide whether a timeout happened -- if the
    thread is still alive, the join() call timed out.
    When the timeout argument is not present or None, the operation will
    block until the thread terminates.
    A thread can be join()ed many times.
    join() raises a RuntimeError if an attempt is made to join the current
    thread as that would cause a deadlock. It is also an error to join() a
    thread before it has been started and attempts to do so raises the same
    exception.
    """
    if not self._initialized:
        raise RuntimeError("Thread.__init__() not called")
    if not self._started.is_set():
        raise RuntimeError("cannot join thread before it is started")
    if self is current_thread():
        raise RuntimeError("cannot join current thread")
    if timeout is None:
        self._wait_for_tstate_lock()
    else:
        # the behavior of a negative timeout isn't documented, but
        # historically .join(timeout=x) for x<0 has acted as if timeout=0
        self._wait_for_tstate_lock(timeout=max(timeout, 0))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.run">
    <p>def <span class="ident">run</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.run', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.run" class="source">
    <pre><code>def run(self):
    while not super().signalKill:
        if not self.theQueue.empty():
            data = self.theQueue.get()
            self.atcObject.putCacheWrapper(*data)
            if self.atcObject._p['verbose'] or self.atcObject._vb:
                printTitle('cache insert successful. queue length: ' + str(self.theQueue.qsize()))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.setDaemon">
    <p>def <span class="ident">setDaemon</span>(</p><p>self, daemonic)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.setDaemon', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.setDaemon" class="source">
    <pre><code>def setDaemon(self, daemonic):
    self.daemon = daemonic
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.setName">
    <p>def <span class="ident">setName</span>(</p><p>self, name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.setName', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.setName" class="source">
    <pre><code>def setName(self, name):
    self.name = name
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.start">
    <p>def <span class="ident">start</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Start the thread's activity.</p>
<p>It must be called at most once per thread object. It arranges for the
object's run() method to be invoked in a separate thread of control.</p>
<p>This method will raise a RuntimeError if called more than once on the
same thread object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.start', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.start" class="source">
    <pre><code>def start(self):
    """Start the thread's activity.
    It must be called at most once per thread object. It arranges for the
    object's run() method to be invoked in a separate thread of control.
    This method will raise a RuntimeError if called more than once on the
    same thread object.
    """
    if not self._initialized:
        raise RuntimeError("thread.__init__() not called")
    if self._started.is_set():
        raise RuntimeError("threads can only be started once")
    with _active_limbo_lock:
        _limbo[self] = self
    try:
        _start_new_thread(self._bootstrap, ())
    except Exception:
        with _active_limbo_lock:
            del _limbo[self]
        raise
    self._started.wait()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.CacheThread.terminate">
    <p>def <span class="ident">terminate</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.CacheThread.terminate', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.CacheThread.terminate" class="source">
    <pre><code>def terminate(self):
    self.__kill_received = True
    if self.isAlive():
        self.join(timeout=0.1)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="gdaAttack.CacheThread.atcObject" class="name">var <span class="ident">atcObject</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.CacheThread.daemon" class="name">var <span class="ident">daemon</span></p>
            

            
  
    <div class="desc"><p>A boolean value indicating whether this thread is a daemon thread.</p>
<p>This must be set before start() is called, otherwise RuntimeError is
raised. Its initial value is inherited from the creating thread; the
main thread is not a daemon thread and therefore all threads created in
the main thread default to daemon = False.</p>
<p>The entire Python program exits when no alive non-daemon threads are
left.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.CacheThread.ident" class="name">var <span class="ident">ident</span></p>
            

            
  
    <div class="desc"><p>Thread identifier of this thread or None if it has not been started.</p>
<p>This is a nonzero integer. See the get_ident() function. Thread
identifiers may be recycled when a thread exits and another thread is
created. The identifier is available even after the thread has exited.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.CacheThread.name" class="name">var <span class="ident">name</span></p>
            

            
  
    <div class="desc"><p>A string used for identification purposes only.</p>
<p>It has no semantics. Multiple threads may be given the same name. The
initial name is set by the constructor.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.CacheThread.signalKill" class="name">var <span class="ident">signalKill</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.CacheThread.theQueue" class="name">var <span class="ident">theQueue</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="gdaAttack.EnhancedThread" class="name">class <span class="ident">EnhancedThread</span></p>
      
  
    <div class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread" class="source">
    <pre><code>class EnhancedThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__kill_received = False
        self.daemon = True

    @property
    def signalKill(self):
        return self.__kill_received

    def terminate(self):
        self.__kill_received = True
        if self.isAlive():
            self.join(timeout=0.1)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#gdaAttack.EnhancedThread">EnhancedThread</a></li>
          <li>threading.Thread</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.__init__', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)
    self.__kill_received = False
    self.daemon = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.getName">
    <p>def <span class="ident">getName</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.getName', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.getName" class="source">
    <pre><code>def getName(self):
    return self.name
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.isAlive">
    <p>def <span class="ident">isAlive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just
after the run() method terminates. The module function enumerate()
returns a list of all alive threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.isAlive', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.isAlive" class="source">
    <pre><code>def is_alive(self):
    """Return whether the thread is alive.
    This method returns True just before the run() method starts until just
    after the run() method terminates. The module function enumerate()
    returns a list of all alive threads.
    """
    assert self._initialized, "Thread.__init__() not called"
    if self._is_stopped or not self._started.is_set():
        return False
    self._wait_for_tstate_lock(False)
    return not self._is_stopped
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.isDaemon">
    <p>def <span class="ident">isDaemon</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.isDaemon', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.isDaemon" class="source">
    <pre><code>def isDaemon(self):
    return self.daemon
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.is_alive">
    <p>def <span class="ident">is_alive</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just
after the run() method terminates. The module function enumerate()
returns a list of all alive threads.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.is_alive', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.is_alive" class="source">
    <pre><code>def is_alive(self):
    """Return whether the thread is alive.
    This method returns True just before the run() method starts until just
    after the run() method terminates. The module function enumerate()
    returns a list of all alive threads.
    """
    assert self._initialized, "Thread.__init__() not called"
    if self._is_stopped or not self._started.is_set():
        return False
    self._wait_for_tstate_lock(False)
    return not self._is_stopped
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.join">
    <p>def <span class="ident">join</span>(</p><p>self, timeout=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait until the thread terminates.</p>
<p>This blocks the calling thread until the thread whose join() method is
called terminates -- either normally or through an unhandled exception
or until the optional timeout occurs.</p>
<p>When the timeout argument is present and not None, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof). As join() always returns None, you must call
isAlive() after join() to decide whether a timeout happened -- if the
thread is still alive, the join() call timed out.</p>
<p>When the timeout argument is not present or None, the operation will
block until the thread terminates.</p>
<p>A thread can be join()ed many times.</p>
<p>join() raises a RuntimeError if an attempt is made to join the current
thread as that would cause a deadlock. It is also an error to join() a
thread before it has been started and attempts to do so raises the same
exception.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.join', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.join" class="source">
    <pre><code>def join(self, timeout=None):
    """Wait until the thread terminates.
    This blocks the calling thread until the thread whose join() method is
    called terminates -- either normally or through an unhandled exception
    or until the optional timeout occurs.
    When the timeout argument is present and not None, it should be a
    floating point number specifying a timeout for the operation in seconds
    (or fractions thereof). As join() always returns None, you must call
    isAlive() after join() to decide whether a timeout happened -- if the
    thread is still alive, the join() call timed out.
    When the timeout argument is not present or None, the operation will
    block until the thread terminates.
    A thread can be join()ed many times.
    join() raises a RuntimeError if an attempt is made to join the current
    thread as that would cause a deadlock. It is also an error to join() a
    thread before it has been started and attempts to do so raises the same
    exception.
    """
    if not self._initialized:
        raise RuntimeError("Thread.__init__() not called")
    if not self._started.is_set():
        raise RuntimeError("cannot join thread before it is started")
    if self is current_thread():
        raise RuntimeError("cannot join current thread")
    if timeout is None:
        self._wait_for_tstate_lock()
    else:
        # the behavior of a negative timeout isn't documented, but
        # historically .join(timeout=x) for x<0 has acted as if timeout=0
        self._wait_for_tstate_lock(timeout=max(timeout, 0))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.run">
    <p>def <span class="ident">run</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.run', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.run" class="source">
    <pre><code>def run(self):
    """Method representing the thread's activity.
    You may override this method in a subclass. The standard run() method
    invokes the callable object passed to the object's constructor as the
    target argument, if any, with sequential and keyword arguments taken
    from the args and kwargs arguments, respectively.
    """
    try:
        if self._target:
            self._target(*self._args, **self._kwargs)
    finally:
        # Avoid a refcycle if the thread is running a function with
        # an argument that has a member that points to the thread.
        del self._target, self._args, self._kwargs
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.setDaemon">
    <p>def <span class="ident">setDaemon</span>(</p><p>self, daemonic)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.setDaemon', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.setDaemon" class="source">
    <pre><code>def setDaemon(self, daemonic):
    self.daemon = daemonic
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.setName">
    <p>def <span class="ident">setName</span>(</p><p>self, name)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.setName', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.setName" class="source">
    <pre><code>def setName(self, name):
    self.name = name
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.start">
    <p>def <span class="ident">start</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Start the thread's activity.</p>
<p>It must be called at most once per thread object. It arranges for the
object's run() method to be invoked in a separate thread of control.</p>
<p>This method will raise a RuntimeError if called more than once on the
same thread object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.start', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.start" class="source">
    <pre><code>def start(self):
    """Start the thread's activity.
    It must be called at most once per thread object. It arranges for the
    object's run() method to be invoked in a separate thread of control.
    This method will raise a RuntimeError if called more than once on the
    same thread object.
    """
    if not self._initialized:
        raise RuntimeError("thread.__init__() not called")
    if self._started.is_set():
        raise RuntimeError("threads can only be started once")
    with _active_limbo_lock:
        _limbo[self] = self
    try:
        _start_new_thread(self._bootstrap, ())
    except Exception:
        with _active_limbo_lock:
            del _limbo[self]
        raise
    self._started.wait()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.EnhancedThread.terminate">
    <p>def <span class="ident">terminate</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.EnhancedThread.terminate', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.EnhancedThread.terminate" class="source">
    <pre><code>def terminate(self):
    self.__kill_received = True
    if self.isAlive():
        self.join(timeout=0.1)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="gdaAttack.EnhancedThread.daemon" class="name">var <span class="ident">daemon</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.EnhancedThread.ident" class="name">var <span class="ident">ident</span></p>
            

            
  
    <div class="desc"><p>Thread identifier of this thread or None if it has not been started.</p>
<p>This is a nonzero integer. See the get_ident() function. Thread
identifiers may be recycled when a thread exits and another thread is
created. The identifier is available even after the thread has exited.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.EnhancedThread.name" class="name">var <span class="ident">name</span></p>
            

            
  
    <div class="desc"><p>A string used for identification purposes only.</p>
<p>It has no semantics. Multiple threads may be given the same name. The
initial name is set by the constructor.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.EnhancedThread.signalKill" class="name">var <span class="ident">signalKill</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="gdaAttack.gdaAttack" class="name">class <span class="ident">gdaAttack</span></p>
      
  
    <div class="desc"><p>Manages a GDA Attack</p>
<p>See <strong>init</strong> for input parameters. <br/>
WARNING: this code is fragile, and can fail ungracefully, or
just hang.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack" class="source">
    <pre><code>class gdaAttack:
    """Manages a GDA Attack

       See __init__ for input parameters. <br/>
       WARNING: this code is fragile, and can fail ungracefully, or
       just hang."""

    def __init__(self, params):
        """ Sets everything up with 'gdaAttack(params)'

            params is a dictionary containing the following
            required parameters: <br/>
            `param['name']`: The name of the attack. Make it unique, because
            the cache is discovered using this name. <br/>
            `param['rawDb']`: The label for the DB to be used as the
            raw (non-anonymized) DB. <br/>
            Following are the optional parameters: <br/>
            `param['criteria']`: The criteria by which the attack should
            determined to succeed or fail. Must be one of 'singlingOut',
            'inference', or 'linkability'. Default is 'singlingOut'. <br/>
            `param['anonDb']`: The label for the DB to be used as the
            anonymized DB. (Is automatically set to `param['rawDb']` if
            not set.) <br/>
            `param['pubDb']`: The label for the DB to be used as the
            publicly known DB in linkability attacks. <br/>
            `param['table']`: The table to be attacked. Must be present
            if the DB has more than one table. <br/>
            `param['uid']`: The uid column for the table. Must be present
            if the name of the column is other than 'uid'. <br/>
            `param['flushCache']`: Set to true if you want the cache of
            query answers from a previous run flushed. The purpose of the
            cache is to save the work from an aborted attack, which can be
            substantial because attacks can have hundreds of queries. <br/>
            `param['locCacheDir']`: The directory holding the cache DBs.
            Default 'cacheDBs'. <br/>
            `param['numRawDbThreads']`: The number of parallel queries
            that can be made to the raw DB. Default 3. <br/>
            `param['numAnonDbThreads']`: The number of parallel queries
            that can be made to the anon DB. Default 3. <br/>
            `param['numPubDbThreads']`: The number of parallel queries
            that can be made to the public linkability DB. Default 3. <br/>
            `param['verbose']`: Set to True for verbose output.
        """

        ########### added by frzmohammadali ##########
        global theCacheQueue
        global theCacheThreadObject
        global flgCacheThreadStarted

        if not theCacheQueue and not theCacheThreadObject:
            theCacheQueue = queue.Queue()
            theCacheThreadObject = CacheThread(theCacheQueue, self)
            printTitle('cache thread initialized.')

        self.cacheQueue = theCacheQueue
        self.cacheThreadObject = theCacheThreadObject
        if not flgCacheThreadStarted:
            self.cacheThreadObject.start()
            flgCacheThreadStarted = True
        ##############################################

        ############## parameters and instance variables ###############
        # ------------- Class called parameters and configured parameters
        self._vb = False
        self._cr = ''  # short for criteria
        self._pp = None  # pretty printer (for debugging)
        self._colNamesTypes = []
        self._colNames = []
        self._p = dict(name='',
                  rawDb='',
                  anonDb='',
                  pubDb='',
                  criteria='singlingOut',
                  table='',
                  uid='uid',
                  flushCache=False,
                  verbose=False,
                  # following not normally set by caller, but can be
                  locCacheDir="cacheDBs",
                  numRawDbThreads=3,
                  numAnonDbThreads=3,
                  numPubDbThreads=3,
                  )
        self._requiredParams = ['name', 'rawDb']

        # ---------- Private internal state
        # Threads
        self._rawThreads = []
        self._anonThreads = []
        self._pubThreads = []
        # Queues read by database threads _rawThreads and _anonThreads
        self._rawQ = None
        self._anonQ = None
        self._pubQ = None
        # Queues read by various caller functions
        self._exploreQ = None
        self._knowledgeQ = None
        self._attackQ = None
        self._claimQ = None
        self._guessQ = None
        # ask/get counters for setting 'stillToCome'
        self._exploreCounter = 0
        self._knowledgeCounter = 0
        self._attackCounter = 0
        self._claimCounter = 0
        self._guessCounter = 0
        # State for computing attack results (see _initAtkRes())
        self._atrs = {}
        # State for various operational measures (see _initOp())
        self._op = {}
        ##############################################

        if self._vb:
            print(f"Calling {__name__}.init")
        if self._vb:
            print(f"   {params}")
        self._initOp()
        self._initCounters()
        self._assignGlobalParams(params)
        self._doParamChecks()
        for param in self._requiredParams:
            if len(self._p[param]) == 0:
                s = str(f"Error: Need param '{param}' in class parameters")
                sys.exit(s)
        # create the database directory if it doesn't exist
        try:
            if not os.path.exists(self._p['locCacheDir']):
                os.makedirs(self._p['locCacheDir'])
        except OSError:
            sys.exit("Error: Creating directory. " + self._p['locCacheDir'])

        # Get the table name if not provided by the caller
        if len(self._p['table']) == 0:
            tables = self.getTableNames()
            if len(tables) != 1:
                print("Error: gdaAttack(): Must include table name if " +
                      "there is more than one table in database")
                sys.exit()
            self._p['table'] = tables[0]

        # Get the column names for computing susceptibility later
        self._colNamesTypes = self.getColNamesAndTypes()
        if self._vb:
            print(f"Columns are '{self._colNamesTypes}'")
        self._initAtkRes()
        # And make a convenient list of column names
        for colNameType in self._colNamesTypes:
            self._colNames.append(colNameType[0])

        # Setup the database which holds already executed queries so we
        # don't have to repeat them if we are restarting
        self._setupLocalCacheDB()
        # Setup the threads and queues
        self._setupThreadsAndQueues()
        numThreads = threading.active_count()
        expectedThreads = (self._p['numRawDbThreads'] +
                           self._p['numAnonDbThreads'] + 1)
        if len(self._p['pubDb']) > 0:
            expectedThreads += self._p['numPubDbThreads']
        if numThreads < expectedThreads:
            print(f"Error: Some thread(s) died "
                  f"(count {numThreads}, expected {expectedThreads}). "
                  f"Aborting.")
            self.cleanUp(cleanUpCache=False, doExit=True)

    def getResults(self):
        """ Returns all of the compiled attack results.

            This can be input to class `gdaScores()` and method
            `gdaScores.addResult()`."""
        # Add the operational parameters
        self._atrs['operational'] = self.getOpParameters()
        self._cleanPasswords()
        return self._atrs

    def getOpParameters(self):
        """ Returns a variety of performance measurements.

            Useful for debugging."""
        self._op['avQueryDuration'] = 0
        if self._op['numQueries'] > 0:
            self._op['avQueryDuration'] = (
                    self._op['timeQueries'] / self._op['numQueries'])
        self._op['avCachePutDuration'] = 0
        if self._op['numCachePuts'] > 0:
            self._op['avCachePutDuration'] = (
                    self._op['timeCachePuts'] / self._op['numCachePuts'])
        self._op['avCacheGetDuration'] = 0
        if self._op['numCacheGets'] > 0:
            self._op['avCacheGetDuration'] = (
                    self._op['timeCacheGets'] / self._op['numCacheGets'])
        return self._op

    def setVerbose(self):
        """Sets Verbose to True"""
        self._vb = True

    def unsetVerbose(self):
        """Sets Verbose to False"""
        self._vb = False

    def cleanUp(self, cleanUpCache=True, doExit=False,
                exitMsg="Finished cleanUp, exiting"):
        """ Garbage collect queues, threads, and cache.

            By default, this wipes the cache. The idea being that if the
            entire attack finished successfully, then it won't be
            repeated and the cache isn't needed. Do `cleanUpCache=False`
            if that isn't what you want."""
        if self._vb: print(f"Calling {__name__}.cleanUp")
        if self._rawQ.empty() != True:
            print("Warning, trying to clean up when raw queue not empty!")
        if self._anonQ.empty() != True:
            print("Warning, trying to clean up when anon queue not empty!")
        if self.cacheQueue.empty() != True:
            print("Warning, trying to clean up when cache queue not empty!")
        # Stuff in end signals for the workers (this is a bit bogus, cause
        # if a thread is gone or hanging, not all signals will get read)
        for i in range(self._p['numRawDbThreads']):
            self._rawQ.put(None)
        for i in range(self._p['numAnonDbThreads']):
            self._anonQ.put(None)

        for i in range(self.cacheQueue.qsize()):
            self.cacheQueue.put(None)

        for t in self._rawThreads + self._anonThreads:
            if t.isAlive(): t.join()

        self.cacheThreadObject.terminate()

        if len(self._p['pubDb']) > 0:
            if self._pubQ.empty() != True:
                print("Warning, trying to clean up when pub queue not empty!")
            for i in range(self._p['numPubDbThreads']):
                self._pubQ.put(None)
            for t in self._pubThreads:
                if t.isAlive(): t.join()
        if cleanUpCache:
            self._removeLocalCacheDB()
        if doExit:
            sys.exit(exitMsg)

    def askClaim(self, spec, cache=True, claim=True):
        """Generate Claim query for raw and optionally pub databases.

        Making a claim results in a query to the raw database, and if
        linkability attack, the pub database, to check
        the correctness of the claim. Multiple calls to this method will
        cause the corresponding queries to be queued up, so `askClaim()`
        returns immediately. `getClaim()` harvests one claim result. <br/>
        Set `claim=False` if this claim should not be applied to the
        confidence improvement score. In this case, the probability score
        will instead be reduced accordingly. <br/>
        The `spec` is formatted as follows: <br/>

            {'known':[{'col':'colName','val':'value'},...],
              'guess':[{'col':'colName','val':'value'},...],
            }

        `spec['known']` are the columns and values the attacker already knows
        (i.e. with prior knowledge). Optional. <br/>
        `spec['guess']` are the columns and values the attacker doesn't know,
        but rather is trying to predict. Mandatory for 'singling out'
        and 'inference'. Optional for 'linkabiblity' <br/>
        Answers are cached <br/>
        Returns immediately"""
        if self._vb: print(f"Calling {__name__}.askClaim with spec '{spec}', count {self._claimCounter}")
        self._claimCounter += 1
        sql = self._makeSqlFromSpec(spec)
        if self._vb: print(f"Sql is '{sql}'")
        sqlConfs = self._makeSqlConfFromSpec(spec)
        if self._vb: print(f"SqlConf is '{sqlConfs}'")
        # Make a copy of the query for passing around
        job = {}
        job['q'] = self._claimQ
        job['claim'] = claim
        job['queries'] = [{'sql': sql, 'cache': cache}]
        job['spec'] = spec
        for sqlConf in sqlConfs:
            job['queries'].append({'sql': sqlConf, 'cache': cache})
        self._rawQ.put(job)

    def getClaim(self):
        """ Wait for and gather results of askClaim() calls

            Returns a data structure that contains both the result
            of one finished claim, and the claim's input parameters.
            Note that the order in which results are returned by
            `getClaim()` are not necessarily the same order they were
            inserted by `askClaim()`. <br/>
            Assuming `result` is returned: <br/>
            `result['claim']` is the value supplied in the corresponding
            `askClaim()` call <br/>
            `result['spec']` is a copy of the `spec` supplied in the
            corresponding `askClaim()` call. <br/>
            `result['queries']` is a list of the queries generated in order to
            validate the claim. <br/>
            `result['answers']` are the answers to the queries in
            `result['queries']`. <br/>
            `result['claimResult']` is 'Correct' or 'Incorrect', depending
            on whether the claim satisfies the critieria or not. <br/>
            `result['stillToCome']` is a counter showing how many more
            claims are still queued. When `stillToCome` is 0, then all
            claims submitted by `askClaim()` have been returned."""

        if self._vb:
            print(f"Calling {__name__}.getClaim")
        if self._claimCounter == 0:
            # Caller shouldn't be calling if there are no expected
            # answers, but is anyway, so just return
            return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                    'stillToCome': 0, 'claimResult': 'Error'}
        job = self._claimQ.get()
        claim = job['claim']
        self._claimQ.task_done()
        self._claimCounter -= 1
        job['stillToCome'] = self._claimCounter
        self._addToAtkRes('claimTrials', job['spec'], 1)
        # The claim is tested against the first reply
        reply = job['replies'][0]
        job['claimResult'] = 'Wrong'
        if claim:
            self._addToAtkRes('claimMade', job['spec'], 1)
        if 'error' in reply:
            self._addToAtkRes('claimError', job['spec'], 1)
            job['claimResult'] = 'Error'
        else:
            if self._cr == 'singlingOut':
                claimIsCorrect = self._checkSinglingOut(reply['answer'])
            elif self._cr == 'inference':
                claimIsCorrect = self._checkInference(reply['answer'])
            elif self._cr == 'linkability':
                claimIsCorrect = self._checkLinkability(reply['answer'])
            if claim == 1 and claimIsCorrect:
                self._addToAtkRes('claimCorrect', job['spec'], 1)
                job['claimResult'] = 'Correct'
            elif claim == 0 and claimIsCorrect:
                self._addToAtkRes('claimPassCorrect', job['spec'], 1)
                job['claimResult'] = 'Correct'
        if self._cr == 'singlingOut' or self._cr == 'inference':
            # Then measure confidence against the second and third replies
            if 'answer' in job['replies'][1]:
                if job['replies'][1]['answer']:
                    guessedRows = job['replies'][1]['answer'][0][0]
                else:
                    guessedRows = 0
            elif 'error' in job['replies'][1]:
                self._pp.pprint(job)
                print(f"Error: conf query:\n{job['replies'][1]['error']}")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if 'answer' in job['replies'][2]:
                if job['replies'][2]['answer']:
                    totalRows = job['replies'][2]['answer'][0][0]
                else:
                    totalRows = 0
            elif 'error' in job['replies'][2]:
                self._pp.pprint(job)
                print(f"Error: conf query:\n{job['replies'][2]['error']}")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if totalRows:
                self._addToAtkRes('sumConfidenceRatios', job['spec'],
                                  guessedRows / totalRows)
                self._addToAtkRes('numConfidenceRatios', job['spec'], 1)
                self._atrs['tableStats']['totalRows'] = totalRows
        else:
            # For linkability, the confidence is always 1/2
            self._addToAtkRes('sumConfidenceRatios', job['spec'], 0.5)
            self._addToAtkRes('numConfidenceRatios', job['spec'], 1)
        if 'q' in job:
            del job['q']
        return (job)

    def askAttack(self, query, cache=True):
        """ Generate and queue up an attack query for database.

            `query` is a dictionary with (currently) one value: <br/>
            `query['sql'] contains the SQL query."""
        self._attackCounter += 1
        if self._vb: print(f"Calling {__name__}.askAttack with query '{query}', count {self._attackCounter}")
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job['q'] = self._attackQ
        qCopy['cache'] = cache
        job['queries'] = [qCopy]
        self._anonQ.put(job)

    def getAttack(self):
        """ Returns the result of one askAttack() call

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askAttack()` calls were made. <br/>
            Assuming `result` is returned: <br/>
            `result['answer']` is the answer returned by the DB. The
            format is: <br/>
                `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` <br/>
            where C1 is the first element of the `SELECT`, C2 the second
            element, etc. <br/>
            `result['cells']` is the number of cells returned in the answer
            (used by `gdaAttack()` to compute total attack cells) <br/>
            `result['query']['sql']` is the query from the corresponding
            `askAttack()`."""

        if self._vb:
            print(f"Calling {__name__}.getAttack")
        if self._attackCounter == 0:
            # Caller shouldn't be calling if there are no expected
            # answers, but is anyway, so just return
            return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                    'stillToCome': 0}
        job = self._attackQ.get()
        self._attackQ.task_done()
        self._attackCounter -= 1
        reply = job['replies'][0]
        reply['stillToCome'] = self._attackCounter
        self._atrs['base']['attackGets'] += 1
        if 'cells' in reply:
            if reply['cells'] == 0:
                self._atrs['base']['attackCells'] += 1
            else:
                self._atrs['base']['attackCells'] += reply['cells']
        else:
            self._atrs['base']['attackCells'] += 1
        return (reply)

    def askKnowledge(self, query, cache=True):
        """ Generate and queue up a prior knowledge query for database

            The class keeps track of how many prior knowledge cells were
            returned and uses this to compute a score. <br/>
            Input parameters formatted the same as with `askAttack()`"""

        self._knowledgeCounter += 1
        if self._vb: print(f"Calling {__name__}.askKnowledge with query "
                           f"'{query}', count {self._knowledgeCounter}")
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job['q'] = self._knowledgeQ
        qCopy['cache'] = cache
        job['queries'] = [qCopy]
        self._rawQ.put(job)

    def getKnowledge(self):
        """ Wait for and gather results of prior askKnowledge() calls

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askKnowledge()` calls were made. <br/>
            Return parameter formatted the same as with `getAttack()`"""

        if self._vb:
            print(f"Calling {__name__}.getKnowledge")
        if self._knowledgeCounter == 0:
            # Caller shouldn't be calling if there are no expected
            # answers, but is anyway, so just return
            return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                    'stillToCome': 0}
        job = self._knowledgeQ.get()
        self._knowledgeQ.task_done()
        self._knowledgeCounter -= 1
        reply = job['replies'][0]
        reply['stillToCome'] = self._knowledgeCounter
        self._atrs['base']['knowledgeGets'] += 1
        if 'cells' in reply:
            self._atrs['base']['knowledgeCells'] += reply['cells']
        return (reply)

    def askExplore(self, query, cache=True):
        """ Generate and queue up an exploritory query for database

            No score book-keeping is done here. An analyst may make
            any number of queries without impacting the GDA score. <br/>
            `query` is a dictionary with two values: <br/>
            `query['sql']` contains the SQL query. <br/>
            `query['db']` determines which database is queried, and
            is one of 'rawDb', 'anonDb', or (if linkability), 'pubDb'."""

        self._exploreCounter += 1
        if self._vb: print(f"Calling {__name__}.askExplore with "
                           f"query '{query}', count {self._exploreCounter}")
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job['q'] = self._exploreQ
        qCopy['cache'] = cache
        job['queries'] = [qCopy]
        if qCopy['db'] == 'rawDb' or qCopy['db'] == 'raw':
            self._rawQ.put(job)
        elif qCopy['db'] == 'anonDb' or qCopy['db'] == 'anon':
            self._anonQ.put(job)
        else:
            self._pubQ.put(job)

    def getExplore(self):
        """ Wait for and gather results of prior askExplore() calls.

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askExplore()` calls were made. <br/>
            Return parameter formatted the same as with `getAttack()`"""
        if self._vb:
            print(f"Calling {__name__}.getExplore")
        if self._exploreCounter == 0:
            # Caller shouldn't be calling if there are no expected
            # answers, but is anyway, so just return
            return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                    'stillToCome': 0}
        job = self._exploreQ.get()
        self._exploreQ.task_done()
        self._exploreCounter -= 1
        reply = job['replies'][0]
        reply['stillToCome'] = self._exploreCounter
        return (reply)

    def getPublicColValues(self, colName, tableName=''):
        """Return list of "publicly known" column values and counts

        Column value has index 0, count of distinct UIDs has index 1
        Must specify column name.
        """
        if len(colName) == 0:
            print(f"Must specify column 'colName'")
            return None

        if len(tableName) == 0:
            # caller didn't supply a table name, so get it from the
            # class init
            tableName = self._p['table']

        # Establish connection to database
        db = getDatabaseInfo(self._p['rawDb'])
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # First we need to know the total number of distinct users
        sql = str(f"""select count(distinct {self._p['uid']})
                      from {tableName}""")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getPublicColValues() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        numUid = ans[0][0]
        # Query the raw db for values in the column
        sql = str(f"""select {colName}, count(distinct {self._p['uid']})
                      from {tableName}
                      group by 1
                      order by 2 desc
                      limit 200""")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getPublicColValues() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            # row[0] is the value, row[1] is the count
            if (((row[1] / numUid) > 0.002) and
                    (row[1] >= 50)):
                ret.append((row[0], row[1]))
        conn.close()
        return ret

    def getColNames(self, dbType='rawDb', tableName=''):
        """Return simple list of column names

        `dbType` is one of 'rawDb' or 'anonDb'"""

        if len(tableName) == 0:
            colsAndTypes = self.getColNamesAndTypes(dbType=dbType)
        else:
            colsAndTypes = self.getColNamesAndTypes(
                dbType=dbType, tableName=tableName)
        if not colsAndTypes:
            return None
        cols = []
        for tup in colsAndTypes:
            cols.append(tup[0])
        return cols

    def getAttackTableName(self):
        """Returns the name of the table being used in the attack."""
        return self._p['table']

    def getTableCharacteristics(self, tableName=''):
        """Returns the full contents of the table characteristics

           Return value is a dict indexed by column name: <br/>

               { '<colName>':
                   {
                       'av_rows_per_vals': 3.93149,
                       'av_uids_per_val': 0.468698,
                       'column_label': 'continuous',
                       'column_name': 'dropoff_latitude',
                       'column_type': 'real',
                       'max': '898.29382000000000',
                       'min': '-0.56333297000000',
                       'num_distinct_vals': 24216,
                       'num_rows': 95205,
                       'num_uids': 11350,
                       'std_rows_per_val': 10.8547,
                       'std_uids_per_val': 4.09688},
                   }
               }

        """
        if len(tableName) == 0:
            # caller didn't supply a table name, so get it from the
            # class init
            tableName = self._p['table']

        # Modify table name to the default for the characteristics table
        tableName += '_char'

        # Establish connection to database
        db = getDatabaseInfo(self._p['rawDb'])
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Set up return dict
        ret = {}
        # Query it for column names
        sql = str(f"""select column_name, data_type 
                  from information_schema.columns where
                  table_name='{tableName}'""")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getTableCharacteristics() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        cols = cur.fetchall()
        # Make index for column name (should be 0, but just to be sure)
        for colNameIndex in range(len(cols)):
            if cols[colNameIndex][0] == 'column_name':
                break

        # Query it for table contents
        sql = str(f"SELECT * FROM {tableName}")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getTableCharacteristics() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        for row in ans:
            colName = row[colNameIndex]
            ret[colName] = {}
            for i in range(len(row)):
                ret[colName][cols[i][0]] = row[i]
        conn.close()
        return ret

    # Note that following is used internally, but we expose it to the
    # caller as well because it is a useful function for exploration
    def getColNamesAndTypes(self, dbType='rawDb', tableName=''):
        """Return raw database column names and types (or None if error)

        dbType is one of 'rawDb' or 'anonDb' <br/>
        return format: [(col,type),(col,type),...]"""
        if len(tableName) == 0:
            # caller didn't supply a table name, so get it from the
            # class init
            tableName = self._p['table']

        # Establish connection to database
        db = getDatabaseInfo(self._p[dbType])
        if db['type'] != 'postgres' and db['type'] != 'aircloak':
            print(f"DB type '{db['type']}' must be 'postgres' or 'aircloak'")
            return None
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Query it for column names
        if db['type'] == 'postgres':
            sql = str(f"""select column_name, data_type 
                      from information_schema.columns where
                      table_name='{tableName}'""")
        elif db['type'] == 'aircloak':
            sql = str(f"show columns from {tableName}")
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getColNamesAndTypes() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            ret.append((row[0], row[1]))
        conn.close()
        return ret

    def getTableNames(self, dbType='rawDb'):
        """Return database table names

        dbType is one of 'rawDb' or 'anonDb' <br/>
        Table names returned as list, unless error then return None"""

        # Establish connection to database
        db = getDatabaseInfo(self._p[dbType])
        if db['type'] != 'postgres' and db['type'] != 'aircloak':
            print(f"DB type '{db['type']}' must be 'postgres' or 'aircloak'")
            return None
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Query it for column names
        if db['type'] == 'postgres':
            sql = """SELECT tablename
                     FROM pg_catalog.pg_tables
                     WHERE schemaname != 'pg_catalog' AND
                           schemaname != 'information_schema'"""
        elif db['type'] == 'aircloak':
            sql = "show tables"
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getTableNames() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            ret.append(row[0])
        conn.close()
        return ret

    def getUidColName(self):
        """ Returns the name of the UID column"""
        return self._p['uid']

    def getPriorKnowledge(self, dataColumns, method,
            fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):
        """ Returns data from the rawDB according to a specification

        This mimics external knowledge that an attacker may have about the data, and
        influences the 'knowledge' part of the GDA Score. <br/>
            `dataColumns` is a list of column names. The data for these columns is returned <br/>
            `method` can be 'rows' or 'users'. If 'rows', then rows are selected
            according to the criteria (`fraction`, `count`, `selectColumn`, `colRange`,
            or `values`).
            If 'users', then all rows for a set of selected users is returned.
            The users are selected according to the criteria (`fraction` or `count`) <br/>
            If none of the criteria are set, or if `fraction` is set to 1.0, then all
            rows are returned (for the selected column values) One of `fraction`, `count`,
            or `selectColumn` must be set. <br/>
            `fraction` or `count` are set to obtain a random set of rows or users. If
            `fraction`, then an approximate fraction of all rows/users is selected.
            `fraction` is a value between 0 and 1.0. If `count`, then exactly `count`
            random rows/users are selected. <br/>
            `selectColumn` is set to select rows according to the values of the specified
            column. `selectColumn` is a column name. If set, then either a range of
            values (`colRange`), or a set of values (`values`) must be chosen. <br/>
            `colRange` is
            a list with two numeric or datetime values: `[min,max]`. This selects all values
            between min and max inclusive. <br/>
            `values` is a list
            of one or more values of any type. This selects all values matching those in
            the list. <br/>
            The return value is a list in this format: <br/>
                `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` <br/>
            where C1 corresponds to the first column in `dataColumns`, C2 corresponds to
            the second column in `dataColumns`, and so on.  <br/>
        """
        # Check input parameters
        if not isinstance(dataColumns, list):
            print(f"getPriorKnowledge Error: dataColumns must be a list of one or more column names")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if method not in ['rows','users']:
            print(f"getPriorKnowledge Error: method must be 'rows' or 'users'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if fraction is None and count is None and selectColumn is None:
            print(f"getPriorKnowledge Error: one of fraction, count, or selectColumn must be set")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if fraction and not isinstance(fraction, float):
            print(f"getPriorKnowledge Error: if set, fraction must be a float")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if (fraction and (count or selectColumn)) or (count and (fraction or selectColumn)):
            print(f"getPriorKnowledge Error: only one of fraction, count, or selectColumn may be set")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if count and not isinstance(count, int):
            print(f"getPriorKnowledge Error: if set, count must be an integer")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if selectColumn: 
            if selectColumn not in self._colNames:
                print(f"getPriorKnowledge Error: selectColumn '{selectColumn}' is not a valid column")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if colRange == [None,None] and values == [None]:
                print(f"getPriorKnowledge Error: if selectColumn is set, one of colRange or values must be set")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if not isinstance(colRange, list):
                print(f"getPriorKnowledge Error: colRange must be a list with two values")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if not isinstance(values, list) or len(values) == 0:
                print(f"getPriorKnowledge Error: values must be a list with one or more values")
                self.cleanUp(cleanUpCache=False, doExit=True)
        for col in dataColumns:
            if col not in self._colNames:
                print(f"getPriorKnowledge Error: column '{col}' is not a valid column")
                self.cleanUp(cleanUpCache=False, doExit=True)
        # Basic input checks finished
        # Establish connection to database
        db = getDatabaseInfo(self._p['rawDb'])
        connStr = str(
            f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        table = self._p['table']
        uid = self._p['uid']
        # Make the SELECT part of the SQL query
        initSql = 'SELECT '
        for col in dataColumns:
            initSql += str(f"{col}, ")
        initSql = initSql[0:-2]
        if method == 'rows' and fraction:
            sql = initSql + str(f" FROM {table} WHERE random() <= {fraction}")
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'users' and fraction:
            sql = initSql + str(f" FROM {table} WHERE {uid} IN ")
            sql += str(f"(SELECT {uid} from (SELECT DISTINCT {uid} FROM {table}) t WHERE random() < {fraction})")
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'rows' and colRange[0] is not None:
            sql = initSql + str(f" FROM {table} WHERE {selectColumn} >= {colRange[0]} and {selectColumn} <= {colRange[1]}")
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'rows' and values[0] is not None:
            sql = initSql + str(f" FROM {table} WHERE {selectColumn} IN (")
            for pair in self._colNamesTypes:
                if selectColumn in pair[0]:
                    colType = pair[1]
                    break
            for value in values:
                if "text" in colType or "date" in colType or "time" in colType:
                    sql += str(f"'{value}', ")
                else:
                    sql += str(f"{value}, ")
            sql = sql[0:-2]
            sql += ")"
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'rows' and count:
            # need to know the total number of rows
            sql = str(f"select count(*) from {table}")
            ans = self._doQuery(cur,sql)
            numRows = ans[0][0]
            # next we get some random set of rows that is certainly more than we need
            frac = (count/numRows)*2
            sql = initSql + str(f" FROM {table} WHERE random() <= {frac}")
            temp = self._doQuery(cur,sql)
            # next we scramble these so that we get a random sampling from the random sampling
            random.shuffle(temp)
            # finally pick the exact count
            ans = temp[0:count]
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        if method == 'users' and count:
            # get the full list of distinct UIDs
            sql = str(f"SELECT DISTINCT {uid} from {table}")
            uidList = self._doQuery(cur,sql)
            # next we scramble these so that we can get a random sampling
            random.shuffle(uidList)
            # pick the exact count of UIDs
            uidList = uidList[0:count]
            sql = initSql + str(f" FROM {table} WHERE {uid} IN (")
            for pair in self._colNamesTypes:
                if uid in pair[0]:
                    colType = pair[1]
                    break
            for uidVal in uidList:
                if "text" in colType or "date" in colType or "time" in colType:
                    sql += str(f"'{uidVal[0]}', ")
                else:
                    sql += str(f"{uidVal[0]}, ")
            sql = sql[0:-2]
            sql += ")"
            ans = self._doQuery(cur,sql)
            self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
            return(ans)
        #zzzz
        return None
    #def getPriorKnowledge(self, dataColumns, method,
            #fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):

    # -------------- Private Methods -------------------
    def _doQuery(self,cur,sql):
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f"Error: getPublicColValues() query: '{e}'")
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        return ans

    def _cleanPasswords(self):
        if 'attack' in self._atrs:
            if ('anonDb' in self._atrs['attack'] and
                    'password' in self._atrs['attack']['anonDb']):
                self._atrs['attack']['anonDb']['password'] = 'xxxxxxx'
            if ('rawDb' in self._atrs['attack'] and
                    'password' in self._atrs['attack']['rawDb']):
                self._atrs['attack']['rawDb']['password'] = 'xxxxxxx'
            if ('pubDb' in self._atrs['attack'] and
                    'password' in self._atrs['attack']['pubDb']):
                self._atrs['attack']['pubDb']['password'] = 'xxxxxxx'

        return

    def _assignGlobalParams(self, params):
        self._pp = pprint.PrettyPrinter(indent=4)
        for key, val in params.items():
            self._p[key] = val
            # assign verbose value to a smaller variable name
            if key == "verbose":
                if val != False:
                    self._vb = True
            # Check criteria
            if key == "criteria":
                if (val == 'singlingOut' or val == 'inference' or
                        val == 'linkability'):
                    self._cr = val
                else:
                    print("""Error: criteria must be one of 'singlingOut',
                             'inference', or 'linkability'""")
                    sys.exit('')

    def _setupLocalCacheDB(self):
        path = self._p['locCacheDir'] + "/" + self._p['name'] + ".db"
        conn = sqlite3.connect(path)
        cur = conn.cursor()
        if self._p['flushCache'] == True:
            sql = "DROP TABLE IF EXISTS tab"
            if self._vb: print(f"   cache DB: {sql}")
            cur.execute(sql)
        sql = """CREATE TABLE IF NOT EXISTS tab
                 (qid text, answer text)"""
        if self._vb: print(f"   cache DB: {sql}")
        cur.execute(sql)
        conn.close()

    def _removeLocalCacheDB(self):
        path = self._p['locCacheDir'] + "/" + self._p['name'] + ".db"
        if os.path.exists(path):
            try:
                os.remove(path)
            except Exception as ex:
                print(f"ERROR: Failed to remove cache DB {path} => ex: {ex}")

    def _setupThreadsAndQueues(self):
        self._anonThreads = []
        self._rawThreads = []
        self._pubThreads = []
        self._exploreQ = queue.Queue()
        self._knowledgeQ = queue.Queue()
        self._attackQ = queue.Queue()
        self._claimQ = queue.Queue()
        self._guessQ = queue.Queue()
        self._rawQ = queue.Queue()
        if self._cr == 'linkability':
            self._pubQ = queue.Queue()
        self._anonQ = queue.Queue()
        backQ = queue.Queue()
        for i in range(self._p['numRawDbThreads']):
            d = dict(db=self._p['rawDb'], q=self._rawQ,
                     kind='raw', backQ=backQ)
            t = EnhancedThread(target=self._dbWorker, kwargs=d)
            t.start()
            self._rawThreads.append(t)
        for i in range(self._p['numAnonDbThreads']):
            d = dict(db=self._p['anonDb'], q=self._anonQ,
                     kind='anon', backQ=backQ)
            t = EnhancedThread(target=self._dbWorker, kwargs=d)
            t.start()
            self._anonThreads.append(t)
        if self._cr == 'linkability':
            for i in range(self._p['numPubDbThreads']):
                d = dict(db=self._p['pubDb'], q=self._pubQ,
                         kind='pub', backQ=backQ)
                t = EnhancedThread(target=self._dbWorker, kwargs=d)
                t.start()
                self._pubThreads.append(t)
        num = (self._p['numRawDbThreads'] + self._p['numAnonDbThreads'])
        if self._cr == 'linkability':
            num += self._p['numPubDbThreads']
        # Make sure all the worker threads are ready
        for i in range(num):
            msg = backQ.get()
            if self._vb: print(f"{msg} is ready")
            backQ.task_done()

    def _dbWorker(self, db, q, kind, backQ):
        if self._vb: print(f"Starting {__name__}.dbWorker:{db, kind}")
        me = threading.current_thread()
        d = getDatabaseInfo(db)
        # Establish connection to database
        connStr = str(
            f"host={d['host']} port={d['port']} dbname={d['dbname']} user={d['user']} password={d['password']}")
        if self._vb: print(f"    {me}: Connect to DB with DSN '{connStr}'")
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Establish connection to local cache
        path = self._p['locCacheDir'] + "/" + self._p['name'] + ".db"
        # Set timeout low so that we don't spend a lot of time inserting
        # into the cache in case it gets overloaded
        connInsert = sqlite3.connect(path, timeout=0.1)
        curInsert = connInsert.cursor()
        connRead = sqlite3.connect(path)
        curRead = connRead.cursor()
        backQ.put(me)
        while True:
            jobOrig = q.get()
            q.task_done()
            if jobOrig is None:
                if self._vb: print(f"    {me}: dbWorker done {db, kind}")
                conn.close()
                connRead.close()
                connInsert.close()
                break
            # make a copy for passing around
            job = copy.copy(jobOrig)
            replyQ = job['q']
            replies = []
            for query in job['queries']:
                reply = self._processQuery(query, conn, cur,
                                           connInsert, curInsert, curRead)
                replies.append(reply)
            job['replies'] = replies
            replyQ.put(job)

    def _processQuery(self, query, conn, cur, connInsert, curInsert, curRead):
        # record and remove the return queue
        cache = query['cache']
        del query['cache']
        # Check the cache for the answer
        # Note that at this point query is a dict
        # containing the sql, the db (raw, anon, or pub),
        # and any tags that the source added
        cachedReply = None
        if cache:
            cachedReply = self._getCache(curRead, query)
        if cachedReply:
            if self._vb: print("    Answer from cache")
            if 'answer' in cachedReply:
                numCells = self._computeNumCells(cachedReply['answer'])
                cachedReply['cells'] = numCells
            return cachedReply
        else:
            start = time.perf_counter()
            try:
                cur.execute(query['sql'])
            except psycopg2.Error as e:
                reply = dict(error=e.pgerror)
            else:
                ans = cur.fetchall()
                numCells = self._computeNumCells(ans)
                reply = dict(answer=ans, cells=numCells)
            end = time.perf_counter()
            duration = end - start
            self._op['numQueries'] += 1
            self._op['timeQueries'] += duration
            reply['query'] = query
            # only cache if the native query is slow
            if duration > 0.1:
                # self._putCache(connInsert, curInsert, query, reply)
                self.cacheQueue.put([connInsert, curInsert, query, reply])
            return reply

    def _checkInference(self, ans):
        # column 0 must be UID
        # User is inferred if all users in answer have same attributes
        # Returns 1 if inference claim correct, else returns 0
        if len(ans) == 0:
            return 0
        numRows = len(ans)
        numColumns = len(ans[0])
        if numColumns < 2:
            # Can't test inference unless there is at least one column
            # (other than UID) that is the same
            return 0
        for c in range(1, numColumns):
            val = ans[0][c]
            for r in range(1, numRows):
                if val != ans[r][c]:
                    return 0
        return 1

    def _checkLinkability(self, ans):
        # The test is the same as with singling out
        # Returns 1 if linkability claim correct, else returns 0
        return self._checkSinglingOut(ans)

    def _checkSinglingOut(self, ans):
        # column 0 must be UID
        # User is singled-out if there is only one distinct UID
        # Returns 1 if singling out claim correct, else returns 0
        if len(ans) == 0:
            return 0
        uids = {}
        for row in ans:
            uids[row[0]] = 1
        numUids = len(uids)
        if numUids == 1:
            return 1
        else:
            return 0

    def _computeNumCells(self, ans):
        # ans is a list of tuples [(x,y),(x,y),(x,y) ...
        # Count the number of columns (in the first row)
        if len(ans) == 0:
            return 0
        numColumns = len(ans[0])
        numRows = len(ans)
        numCells = numColumns * numRows
        return numCells

    def _doParamChecks(self):
        dbInfoRaw = getDatabaseInfo(self._p['rawDb'])
        if not dbInfoRaw:
            sys.exit('rawDb now found in database config')
        if len(self._p['anonDb']) == 0:
            self._p['anonDb'] = self._p['rawDb']
        else:
            dbInfoAnon = getDatabaseInfo(self._p['anonDb'])
            if not dbInfoAnon:
                sys.exit('anonDb not found in database config')
        if self._cr == 'linkability':
            dbInfo = getDatabaseInfo(self._p['pubDb'])
            if not dbInfo:
                sys.exit('Must specify pubDb if criteria is linkability')
        numThreads = self._p['numRawDbThreads'] + self._p['numAnonDbThreads']
        if self._cr == 'linkability':
            numThreads += self._p['numPubDbThreads']
        if numThreads > 50:
            sys.exit("Error: Can't have more than 50 threads total")

    def _getCache(self, cur, query):
        # turn the query (dict) into a string
        qStr = self._dict2Str(query)
        if qStr is None:
            return None
        sql = str(f"SELECT answer FROM tab where qid = '{qStr}'")
        if self._vb: print(f"   cache DB: {sql}")
        start = time.perf_counter()
        try:
            cur.execute(sql)
        except sqlite3.Error as e:
            print(f"getCache error '{e.args[0]}'")
            return None
        end = time.perf_counter()
        self._op['numCacheGets'] += 1
        self._op['timeCacheGets'] += (end - start)
        answer = cur.fetchone()
        if not answer:
            return None
        rtnDict = self._str2Dict(answer[0])
        return rtnDict

    def _putCache(self, conn, cur, query, reply):
        # turn the query and reply (dict) into a string
        qStr = self._dict2Str(query)
        if qStr is None:
            return
        rStr = self._dict2Str(reply)
        if rStr is None:
            return
        sql = str(f"INSERT INTO tab VALUES ('{qStr}','{rStr}')")
        if self._vb: print(f"   cache DB: {sql}")
        start = time.perf_counter()
        err = None
        for z in range(10):
            try:
                cur.execute(sql)
                conn.commit()
            except sqlite3.OperationalError as e:
                if self._p['verbose'] or self._vb:
                    print(f"putCache error '{e.args[0]}'")
                err = e
                continue
            except sqlite3.Error as e:
                if self._p['verbose'] or self._vb:
                    print(f"putCache error '{e.args[0]}'")
                err = e
                continue
            else:
                break
        else:
            # raise err
            if self._p['verbose'] or self._vb:
                print(f'>> could not insert into cache DB >> ERROR: {err}')

        end = time.perf_counter()
        self._op['numCachePuts'] += 1
        self._op['timeCachePuts'] += (end - start)

    def putCacheWrapper(self, conn, cur, query, reply):
        self._putCache(conn, cur, query, reply)

    def _dict2Str(self, d):
        try:
            dStr = simplejson.dumps(d)
        except TypeError:
            print("simpleJson failed")
            return None
        dByte = str.encode(dStr)
        dByte64 = base64.b64encode(dByte)
        try:
            dByte64Str = str(dByte64, "utf-8")
        except MemoryError:
            print("str(dByte64) failed")
            return None
        return dByte64Str

    def _str2Dict(self, dByte64Str):
        dByte64 = str.encode(dByte64Str)
        dByte = base64.b64decode(dByte64)
        dStr = str(dByte, "utf-8")
        d = simplejson.loads(dStr)
        return d

    def _makeSqlFromSpec(self, spec):
        sql = "select "
        if 'known' in spec:
            numKnown = len(spec['known'])
        else:
            numKnown = 0
        if 'guess' in spec:
            numGuess = len(spec['guess'])
        else:
            numGuess = 0
        if self._cr == 'inference':
            sql += str(f"{self._p['uid']}, ")
            for i in range(numGuess):
                sql += str(f"{spec['guess'][i]['col']}")
                if i == (numGuess - 1):
                    sql += " "
                else:
                    sql += ", "
            sql += str(f"from {self._p['table']} ")
            if numKnown:
                sql += "where "
            for i in range(numKnown):
                sql += str(f"{spec['known'][i]['col']} = ")
                sql += str(f"'{spec['known'][i]['val']}' ")
                if i == (numKnown - 1):
                    sql += " "
                else:
                    sql += "and "
        elif self._cr == 'singlingOut' or self._cr == 'linkability':
            sql += str(f"{self._p['uid']} from {self._p['table']} where ")
            for i in range(numKnown):
                sql += str(f"{spec['known'][i]['col']} = ")
                sql += str(f"'{spec['known'][i]['val']}' and ")
            for i in range(numGuess):
                sql += str(f"{spec['guess'][i]['col']} = ")
                sql += str(f"'{spec['guess'][i]['val']}' ")
                if i == (numGuess - 1):
                    sql += " "
                else:
                    sql += "and "
        return sql

    def _makeSqlConfFromSpec(self, spec):
        sqls = []
        numGuess = len(spec['guess'])
        if self._cr == 'inference' or self._cr == 'singlingOut':
            sql = str(f"select count(*) from {self._p['table']} where ")
            # This first sql learns the number of rows matching the
            # guessed values
            for i in range(numGuess):
                sql += str(f"{spec['guess'][i]['col']} = ")
                sql += str(f"'{spec['guess'][i]['val']}'")
                if i != (numGuess - 1):
                    sql += " and "
            sqls.append(sql)
            # This second sql learns the total number of rows (should
            # normally be a cached result)
            sql = str(f"select count(*) from {self._p['table']}")
            sqls.append(sql)
        elif self._cr == 'linkability':
            # nothing happens for linkability
            pass
        return sqls

    def _addToAtkRes(self, label, spec, val):
        """Adds the value to each column in the guess"""
        for tup in spec['guess']:
            col = tup['col']
            if col not in self._atrs['col']:
                print(f"Error: addToAtkRes(): Bad column in spec: '{col}'")
                self.cleanUp(cleanUpCache=False, doExit=True)
            if label not in self._atrs['col'][col]:
                print(f"Error: addToAtkRes(): Bad label '{label}'")
                self.cleanUp(cleanUpCache=False, doExit=True)
            self._atrs['col'][col][label] += val

    def _initAtkRes(self):
        self._atrs = {}
        self._atrs['attack'] = {}
        self._atrs['base'] = {}
        self._atrs['tableStats'] = {}
        self._atrs['col'] = {}
        # ----- Attack parameters
        self._atrs['attack']['attackName'] = self._p['name']
        self._atrs['attack']['rawDb'] = self._p['rawDb']
        self._atrs['attack']['anonDb'] = self._p['anonDb']
        if self._cr == 'linkability':
            self._atrs['attack']['pubDb'] = self._p['anonDb']
        self._atrs['attack']['criteria'] = self._p['criteria']
        self._atrs['attack']['table'] = self._p['table']
        # add parameters for the database machine itself
        db = getDatabaseInfo(self._p['rawDb'])
        self._atrs['attack']['rawHost'] = db['host']
        self._atrs['attack']['rawDbName'] = db['dbname']
        self._atrs['attack']['rawPort'] = db['port']
        if self._cr == 'linkability':
            db = getDatabaseInfo(self._p['pubDb'])
            self._atrs['attack']['pubHost'] = db['host']
            self._atrs['attack']['pubDbName'] = db['dbname']
            self._atrs['attack']['pubPort'] = db['port']
        db = getDatabaseInfo(self._p['anonDb'])
        self._atrs['attack']['anonHost'] = db['host']
        self._atrs['attack']['anonDbName'] = db['dbname']
        self._atrs['attack']['anonPort'] = db['port']
        # and a timestamp
        self._atrs['attack']['startTime'] = str(datetime.datetime.now())
        # ----- Params for computing knowledge:
        # number of prior knowledge cells requested
        self._atrs['base']['knowledgeCells'] = 0
        # number of times knowledge was queried
        self._atrs['base']['knowledgeGets'] = 0

        # ----- Params for computing how much work needed to attack:
        # number of attack cells requested
        self._atrs['base']['attackCells'] = 0
        # number of times attack was queried
        self._atrs['base']['attackGets'] = 0
        self._atrs['tableStats']['colNamesAndTypes'] = self._colNamesTypes
        self._atrs['tableStats']['numColumns'] = len(self._colNamesTypes)
        for tup in self._colNamesTypes:
            col = tup[0]
            if self._vb: print(f"initAtkRes() init column '{col}'")
            self._atrs['col'][col] = {}

            # ----- Params for computing claim success rate:
            # total possible number of claims
            self._atrs['col'][col]['claimTrials'] = 0
            # actual number of claims
            self._atrs['col'][col]['claimMade'] = 0
            # number of correct claims
            self._atrs['col'][col]['claimCorrect'] = 0
            # number of claims that produced bad SQL answer
            self._atrs['col'][col]['claimError'] = 0
            # claims where the attacker chose to pass (not make a claim),
            # but where the claim would have been correct
            self._atrs['col'][col]['claimPassCorrect'] = 0

            # ----- Params for computing confidence:
            # sum of all known count to full count ratios
            self._atrs['col'][col]['sumConfidenceRatios'] = 0
            # number of such ratios
            self._atrs['col'][col]['numConfidenceRatios'] = 0
            # average confidence ratio (division of above two params)
            self._atrs['col'][col]['avgConfidenceRatios'] = 0

    def _initOp(self):
        self._op['numQueries'] = 0
        self._op['timeQueries'] = 0
        self._op['numCachePuts'] = 0
        self._op['timeCachePuts'] = 0
        self._op['numCacheGets'] = 0
        self._op['timeCacheGets'] = 0

    def _initCounters(self):
        self._exploreCounter = 0
        self._knowledgeCounter = 0
        self._attackCounter = 0
        self._claimCounter = 0
        self._guessCounter = 0

    def __del__(self):
        self.cacheThreadObject.terminate()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#gdaAttack.gdaAttack">gdaAttack</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, params)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets everything up with 'gdaAttack(params)'</p>
<p>params is a dictionary containing the following
required parameters: <br/>
<code>param['name']</code>: The name of the attack. Make it unique, because
the cache is discovered using this name. <br/>
<code>param['rawDb']</code>: The label for the DB to be used as the
raw (non-anonymized) DB. <br/>
Following are the optional parameters: <br/>
<code>param['criteria']</code>: The criteria by which the attack should
determined to succeed or fail. Must be one of 'singlingOut',
'inference', or 'linkability'. Default is 'singlingOut'. <br/>
<code>param['anonDb']</code>: The label for the DB to be used as the
anonymized DB. (Is automatically set to <code>param['rawDb']</code> if
not set.) <br/>
<code>param['pubDb']</code>: The label for the DB to be used as the
publicly known DB in linkability attacks. <br/>
<code>param['table']</code>: The table to be attacked. Must be present
if the DB has more than one table. <br/>
<code>param['uid']</code>: The uid column for the table. Must be present
if the name of the column is other than 'uid'. <br/>
<code>param['flushCache']</code>: Set to true if you want the cache of
query answers from a previous run flushed. The purpose of the
cache is to save the work from an aborted attack, which can be
substantial because attacks can have hundreds of queries. <br/>
<code>param['locCacheDir']</code>: The directory holding the cache DBs.
Default 'cacheDBs'. <br/>
<code>param['numRawDbThreads']</code>: The number of parallel queries
that can be made to the raw DB. Default 3. <br/>
<code>param['numAnonDbThreads']</code>: The number of parallel queries
that can be made to the anon DB. Default 3. <br/>
<code>param['numPubDbThreads']</code>: The number of parallel queries
that can be made to the public linkability DB. Default 3. <br/>
<code>param['verbose']</code>: Set to True for verbose output.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.__init__', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.__init__" class="source">
    <pre><code>def __init__(self, params):
    """ Sets everything up with 'gdaAttack(params)'
        params is a dictionary containing the following
        required parameters: <br/>
        `param['name']`: The name of the attack. Make it unique, because
        the cache is discovered using this name. <br/>
        `param['rawDb']`: The label for the DB to be used as the
        raw (non-anonymized) DB. <br/>
        Following are the optional parameters: <br/>
        `param['criteria']`: The criteria by which the attack should
        determined to succeed or fail. Must be one of 'singlingOut',
        'inference', or 'linkability'. Default is 'singlingOut'. <br/>
        `param['anonDb']`: The label for the DB to be used as the
        anonymized DB. (Is automatically set to `param['rawDb']` if
        not set.) <br/>
        `param['pubDb']`: The label for the DB to be used as the
        publicly known DB in linkability attacks. <br/>
        `param['table']`: The table to be attacked. Must be present
        if the DB has more than one table. <br/>
        `param['uid']`: The uid column for the table. Must be present
        if the name of the column is other than 'uid'. <br/>
        `param['flushCache']`: Set to true if you want the cache of
        query answers from a previous run flushed. The purpose of the
        cache is to save the work from an aborted attack, which can be
        substantial because attacks can have hundreds of queries. <br/>
        `param['locCacheDir']`: The directory holding the cache DBs.
        Default 'cacheDBs'. <br/>
        `param['numRawDbThreads']`: The number of parallel queries
        that can be made to the raw DB. Default 3. <br/>
        `param['numAnonDbThreads']`: The number of parallel queries
        that can be made to the anon DB. Default 3. <br/>
        `param['numPubDbThreads']`: The number of parallel queries
        that can be made to the public linkability DB. Default 3. <br/>
        `param['verbose']`: Set to True for verbose output.
    """
    ########### added by frzmohammadali ##########
    global theCacheQueue
    global theCacheThreadObject
    global flgCacheThreadStarted
    if not theCacheQueue and not theCacheThreadObject:
        theCacheQueue = queue.Queue()
        theCacheThreadObject = CacheThread(theCacheQueue, self)
        printTitle('cache thread initialized.')
    self.cacheQueue = theCacheQueue
    self.cacheThreadObject = theCacheThreadObject
    if not flgCacheThreadStarted:
        self.cacheThreadObject.start()
        flgCacheThreadStarted = True
    ##############################################
    ############## parameters and instance variables ###############
    # ------------- Class called parameters and configured parameters
    self._vb = False
    self._cr = ''  # short for criteria
    self._pp = None  # pretty printer (for debugging)
    self._colNamesTypes = []
    self._colNames = []
    self._p = dict(name='',
              rawDb='',
              anonDb='',
              pubDb='',
              criteria='singlingOut',
              table='',
              uid='uid',
              flushCache=False,
              verbose=False,
              # following not normally set by caller, but can be
              locCacheDir="cacheDBs",
              numRawDbThreads=3,
              numAnonDbThreads=3,
              numPubDbThreads=3,
              )
    self._requiredParams = ['name', 'rawDb']
    # ---------- Private internal state
    # Threads
    self._rawThreads = []
    self._anonThreads = []
    self._pubThreads = []
    # Queues read by database threads _rawThreads and _anonThreads
    self._rawQ = None
    self._anonQ = None
    self._pubQ = None
    # Queues read by various caller functions
    self._exploreQ = None
    self._knowledgeQ = None
    self._attackQ = None
    self._claimQ = None
    self._guessQ = None
    # ask/get counters for setting 'stillToCome'
    self._exploreCounter = 0
    self._knowledgeCounter = 0
    self._attackCounter = 0
    self._claimCounter = 0
    self._guessCounter = 0
    # State for computing attack results (see _initAtkRes())
    self._atrs = {}
    # State for various operational measures (see _initOp())
    self._op = {}
    ##############################################
    if self._vb:
        print(f"Calling {__name__}.init")
    if self._vb:
        print(f"   {params}")
    self._initOp()
    self._initCounters()
    self._assignGlobalParams(params)
    self._doParamChecks()
    for param in self._requiredParams:
        if len(self._p[param]) == 0:
            s = str(f"Error: Need param '{param}' in class parameters")
            sys.exit(s)
    # create the database directory if it doesn't exist
    try:
        if not os.path.exists(self._p['locCacheDir']):
            os.makedirs(self._p['locCacheDir'])
    except OSError:
        sys.exit("Error: Creating directory. " + self._p['locCacheDir'])
    # Get the table name if not provided by the caller
    if len(self._p['table']) == 0:
        tables = self.getTableNames()
        if len(tables) != 1:
            print("Error: gdaAttack(): Must include table name if " +
                  "there is more than one table in database")
            sys.exit()
        self._p['table'] = tables[0]
    # Get the column names for computing susceptibility later
    self._colNamesTypes = self.getColNamesAndTypes()
    if self._vb:
        print(f"Columns are '{self._colNamesTypes}'")
    self._initAtkRes()
    # And make a convenient list of column names
    for colNameType in self._colNamesTypes:
        self._colNames.append(colNameType[0])
    # Setup the database which holds already executed queries so we
    # don't have to repeat them if we are restarting
    self._setupLocalCacheDB()
    # Setup the threads and queues
    self._setupThreadsAndQueues()
    numThreads = threading.active_count()
    expectedThreads = (self._p['numRawDbThreads'] +
                       self._p['numAnonDbThreads'] + 1)
    if len(self._p['pubDb']) > 0:
        expectedThreads += self._p['numPubDbThreads']
    if numThreads < expectedThreads:
        print(f"Error: Some thread(s) died "
              f"(count {numThreads}, expected {expectedThreads}). "
              f"Aborting.")
        self.cleanUp(cleanUpCache=False, doExit=True)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.askAttack">
    <p>def <span class="ident">askAttack</span>(</p><p>self, query, cache=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate and queue up an attack query for database.</p>
<p><code>query</code> is a dictionary with (currently) one value: <br/>
`query['sql'] contains the SQL query.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.askAttack', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.askAttack" class="source">
    <pre><code>def askAttack(self, query, cache=True):
    """ Generate and queue up an attack query for database.
        `query` is a dictionary with (currently) one value: <br/>
        `query['sql'] contains the SQL query."""
    self._attackCounter += 1
    if self._vb: print(f"Calling {__name__}.askAttack with query '{query}', count {self._attackCounter}")
    # Make a copy of the query for passing around
    qCopy = copy.copy(query)
    job = {}
    job['q'] = self._attackQ
    qCopy['cache'] = cache
    job['queries'] = [qCopy]
    self._anonQ.put(job)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.askClaim">
    <p>def <span class="ident">askClaim</span>(</p><p>self, spec, cache=True, claim=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate Claim query for raw and optionally pub databases.</p>
<p>Making a claim results in a query to the raw database, and if
linkability attack, the pub database, to check
the correctness of the claim. Multiple calls to this method will
cause the corresponding queries to be queued up, so <code>askClaim()</code>
returns immediately. <code>getClaim()</code> harvests one claim result. <br/>
Set <code>claim=False</code> if this claim should not be applied to the
confidence improvement score. In this case, the probability score
will instead be reduced accordingly. <br/>
The <code>spec</code> is formatted as follows: <br/></p>
<pre><code>{'known':[{'col':'colName','val':'value'},...],
  'guess':[{'col':'colName','val':'value'},...],
}
</code></pre>
<p><code>spec['known']</code> are the columns and values the attacker already knows
(i.e. with prior knowledge). Optional. <br/>
<code>spec['guess']</code> are the columns and values the attacker doesn't know,
but rather is trying to predict. Mandatory for 'singling out'
and 'inference'. Optional for 'linkabiblity' <br/>
Answers are cached <br/>
Returns immediately</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.askClaim', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.askClaim" class="source">
    <pre><code>def askClaim(self, spec, cache=True, claim=True):
    """Generate Claim query for raw and optionally pub databases.
    Making a claim results in a query to the raw database, and if
    linkability attack, the pub database, to check
    the correctness of the claim. Multiple calls to this method will
    cause the corresponding queries to be queued up, so `askClaim()`
    returns immediately. `getClaim()` harvests one claim result. <br/>
    Set `claim=False` if this claim should not be applied to the
    confidence improvement score. In this case, the probability score
    will instead be reduced accordingly. <br/>
    The `spec` is formatted as follows: <br/>
        {'known':[{'col':'colName','val':'value'},...],
          'guess':[{'col':'colName','val':'value'},...],
        }
    `spec['known']` are the columns and values the attacker already knows
    (i.e. with prior knowledge). Optional. <br/>
    `spec['guess']` are the columns and values the attacker doesn't know,
    but rather is trying to predict. Mandatory for 'singling out'
    and 'inference'. Optional for 'linkabiblity' <br/>
    Answers are cached <br/>
    Returns immediately"""
    if self._vb: print(f"Calling {__name__}.askClaim with spec '{spec}', count {self._claimCounter}")
    self._claimCounter += 1
    sql = self._makeSqlFromSpec(spec)
    if self._vb: print(f"Sql is '{sql}'")
    sqlConfs = self._makeSqlConfFromSpec(spec)
    if self._vb: print(f"SqlConf is '{sqlConfs}'")
    # Make a copy of the query for passing around
    job = {}
    job['q'] = self._claimQ
    job['claim'] = claim
    job['queries'] = [{'sql': sql, 'cache': cache}]
    job['spec'] = spec
    for sqlConf in sqlConfs:
        job['queries'].append({'sql': sqlConf, 'cache': cache})
    self._rawQ.put(job)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.askExplore">
    <p>def <span class="ident">askExplore</span>(</p><p>self, query, cache=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate and queue up an exploritory query for database</p>
<p>No score book-keeping is done here. An analyst may make
any number of queries without impacting the GDA score. <br/>
<code>query</code> is a dictionary with two values: <br/>
<code>query['sql']</code> contains the SQL query. <br/>
<code>query['db']</code> determines which database is queried, and
is one of 'rawDb', 'anonDb', or (if linkability), 'pubDb'.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.askExplore', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.askExplore" class="source">
    <pre><code>def askExplore(self, query, cache=True):
    """ Generate and queue up an exploritory query for database
        No score book-keeping is done here. An analyst may make
        any number of queries without impacting the GDA score. <br/>
        `query` is a dictionary with two values: <br/>
        `query['sql']` contains the SQL query. <br/>
        `query['db']` determines which database is queried, and
        is one of 'rawDb', 'anonDb', or (if linkability), 'pubDb'."""
    self._exploreCounter += 1
    if self._vb: print(f"Calling {__name__}.askExplore with "
                       f"query '{query}', count {self._exploreCounter}")
    # Make a copy of the query for passing around
    qCopy = copy.copy(query)
    job = {}
    job['q'] = self._exploreQ
    qCopy['cache'] = cache
    job['queries'] = [qCopy]
    if qCopy['db'] == 'rawDb' or qCopy['db'] == 'raw':
        self._rawQ.put(job)
    elif qCopy['db'] == 'anonDb' or qCopy['db'] == 'anon':
        self._anonQ.put(job)
    else:
        self._pubQ.put(job)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.askKnowledge">
    <p>def <span class="ident">askKnowledge</span>(</p><p>self, query, cache=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate and queue up a prior knowledge query for database</p>
<p>The class keeps track of how many prior knowledge cells were
returned and uses this to compute a score. <br/>
Input parameters formatted the same as with <code>askAttack()</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.askKnowledge', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.askKnowledge" class="source">
    <pre><code>def askKnowledge(self, query, cache=True):
    """ Generate and queue up a prior knowledge query for database
        The class keeps track of how many prior knowledge cells were
        returned and uses this to compute a score. <br/>
        Input parameters formatted the same as with `askAttack()`"""
    self._knowledgeCounter += 1
    if self._vb: print(f"Calling {__name__}.askKnowledge with query "
                       f"'{query}', count {self._knowledgeCounter}")
    # Make a copy of the query for passing around
    qCopy = copy.copy(query)
    job = {}
    job['q'] = self._knowledgeQ
    qCopy['cache'] = cache
    job['queries'] = [qCopy]
    self._rawQ.put(job)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.cleanUp">
    <p>def <span class="ident">cleanUp</span>(</p><p>self, cleanUpCache=True, doExit=False, exitMsg=&#39;Finished cleanUp, exiting&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Garbage collect queues, threads, and cache.</p>
<p>By default, this wipes the cache. The idea being that if the
entire attack finished successfully, then it won't be
repeated and the cache isn't needed. Do <code>cleanUpCache=False</code>
if that isn't what you want.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.cleanUp', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.cleanUp" class="source">
    <pre><code>def cleanUp(self, cleanUpCache=True, doExit=False,
            exitMsg="Finished cleanUp, exiting"):
    """ Garbage collect queues, threads, and cache.
        By default, this wipes the cache. The idea being that if the
        entire attack finished successfully, then it won't be
        repeated and the cache isn't needed. Do `cleanUpCache=False`
        if that isn't what you want."""
    if self._vb: print(f"Calling {__name__}.cleanUp")
    if self._rawQ.empty() != True:
        print("Warning, trying to clean up when raw queue not empty!")
    if self._anonQ.empty() != True:
        print("Warning, trying to clean up when anon queue not empty!")
    if self.cacheQueue.empty() != True:
        print("Warning, trying to clean up when cache queue not empty!")
    # Stuff in end signals for the workers (this is a bit bogus, cause
    # if a thread is gone or hanging, not all signals will get read)
    for i in range(self._p['numRawDbThreads']):
        self._rawQ.put(None)
    for i in range(self._p['numAnonDbThreads']):
        self._anonQ.put(None)
    for i in range(self.cacheQueue.qsize()):
        self.cacheQueue.put(None)
    for t in self._rawThreads + self._anonThreads:
        if t.isAlive(): t.join()
    self.cacheThreadObject.terminate()
    if len(self._p['pubDb']) > 0:
        if self._pubQ.empty() != True:
            print("Warning, trying to clean up when pub queue not empty!")
        for i in range(self._p['numPubDbThreads']):
            self._pubQ.put(None)
        for t in self._pubThreads:
            if t.isAlive(): t.join()
    if cleanUpCache:
        self._removeLocalCacheDB()
    if doExit:
        sys.exit(exitMsg)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getAttack">
    <p>def <span class="ident">getAttack</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the result of one askAttack() call</p>
<p>Blocks until the result is available. Note that the order
in which results are received is not necesarily the order
in which <code>askAttack()</code> calls were made. <br/>
Assuming <code>result</code> is returned: <br/>
<code>result['answer']</code> is the answer returned by the DB. The
format is: <br/>
    <code>[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]</code> <br/>
where C1 is the first element of the <code>SELECT</code>, C2 the second
element, etc. <br/>
<code>result['cells']</code> is the number of cells returned in the answer
(used by <code>gdaAttack()</code> to compute total attack cells) <br/>
<code>result['query']['sql']</code> is the query from the corresponding
<code>askAttack()</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getAttack', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getAttack" class="source">
    <pre><code>def getAttack(self):
    """ Returns the result of one askAttack() call
        Blocks until the result is available. Note that the order
        in which results are received is not necesarily the order
        in which `askAttack()` calls were made. <br/>
        Assuming `result` is returned: <br/>
        `result['answer']` is the answer returned by the DB. The
        format is: <br/>
            `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` <br/>
        where C1 is the first element of the `SELECT`, C2 the second
        element, etc. <br/>
        `result['cells']` is the number of cells returned in the answer
        (used by `gdaAttack()` to compute total attack cells) <br/>
        `result['query']['sql']` is the query from the corresponding
        `askAttack()`."""
    if self._vb:
        print(f"Calling {__name__}.getAttack")
    if self._attackCounter == 0:
        # Caller shouldn't be calling if there are no expected
        # answers, but is anyway, so just return
        return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                'stillToCome': 0}
    job = self._attackQ.get()
    self._attackQ.task_done()
    self._attackCounter -= 1
    reply = job['replies'][0]
    reply['stillToCome'] = self._attackCounter
    self._atrs['base']['attackGets'] += 1
    if 'cells' in reply:
        if reply['cells'] == 0:
            self._atrs['base']['attackCells'] += 1
        else:
            self._atrs['base']['attackCells'] += reply['cells']
    else:
        self._atrs['base']['attackCells'] += 1
    return (reply)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getAttackTableName">
    <p>def <span class="ident">getAttackTableName</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the name of the table being used in the attack.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getAttackTableName', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getAttackTableName" class="source">
    <pre><code>def getAttackTableName(self):
    """Returns the name of the table being used in the attack."""
    return self._p['table']
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getClaim">
    <p>def <span class="ident">getClaim</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait for and gather results of askClaim() calls</p>
<p>Returns a data structure that contains both the result
of one finished claim, and the claim's input parameters.
Note that the order in which results are returned by
<code>getClaim()</code> are not necessarily the same order they were
inserted by <code>askClaim()</code>. <br/>
Assuming <code>result</code> is returned: <br/>
<code>result['claim']</code> is the value supplied in the corresponding
<code>askClaim()</code> call <br/>
<code>result['spec']</code> is a copy of the <code>spec</code> supplied in the
corresponding <code>askClaim()</code> call. <br/>
<code>result['queries']</code> is a list of the queries generated in order to
validate the claim. <br/>
<code>result['answers']</code> are the answers to the queries in
<code>result['queries']</code>. <br/>
<code>result['claimResult']</code> is 'Correct' or 'Incorrect', depending
on whether the claim satisfies the critieria or not. <br/>
<code>result['stillToCome']</code> is a counter showing how many more
claims are still queued. When <code>stillToCome</code> is 0, then all
claims submitted by <code>askClaim()</code> have been returned.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getClaim', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getClaim" class="source">
    <pre><code>def getClaim(self):
    """ Wait for and gather results of askClaim() calls
        Returns a data structure that contains both the result
        of one finished claim, and the claim's input parameters.
        Note that the order in which results are returned by
        `getClaim()` are not necessarily the same order they were
        inserted by `askClaim()`. <br/>
        Assuming `result` is returned: <br/>
        `result['claim']` is the value supplied in the corresponding
        `askClaim()` call <br/>
        `result['spec']` is a copy of the `spec` supplied in the
        corresponding `askClaim()` call. <br/>
        `result['queries']` is a list of the queries generated in order to
        validate the claim. <br/>
        `result['answers']` are the answers to the queries in
        `result['queries']`. <br/>
        `result['claimResult']` is 'Correct' or 'Incorrect', depending
        on whether the claim satisfies the critieria or not. <br/>
        `result['stillToCome']` is a counter showing how many more
        claims are still queued. When `stillToCome` is 0, then all
        claims submitted by `askClaim()` have been returned."""
    if self._vb:
        print(f"Calling {__name__}.getClaim")
    if self._claimCounter == 0:
        # Caller shouldn't be calling if there are no expected
        # answers, but is anyway, so just return
        return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                'stillToCome': 0, 'claimResult': 'Error'}
    job = self._claimQ.get()
    claim = job['claim']
    self._claimQ.task_done()
    self._claimCounter -= 1
    job['stillToCome'] = self._claimCounter
    self._addToAtkRes('claimTrials', job['spec'], 1)
    # The claim is tested against the first reply
    reply = job['replies'][0]
    job['claimResult'] = 'Wrong'
    if claim:
        self._addToAtkRes('claimMade', job['spec'], 1)
    if 'error' in reply:
        self._addToAtkRes('claimError', job['spec'], 1)
        job['claimResult'] = 'Error'
    else:
        if self._cr == 'singlingOut':
            claimIsCorrect = self._checkSinglingOut(reply['answer'])
        elif self._cr == 'inference':
            claimIsCorrect = self._checkInference(reply['answer'])
        elif self._cr == 'linkability':
            claimIsCorrect = self._checkLinkability(reply['answer'])
        if claim == 1 and claimIsCorrect:
            self._addToAtkRes('claimCorrect', job['spec'], 1)
            job['claimResult'] = 'Correct'
        elif claim == 0 and claimIsCorrect:
            self._addToAtkRes('claimPassCorrect', job['spec'], 1)
            job['claimResult'] = 'Correct'
    if self._cr == 'singlingOut' or self._cr == 'inference':
        # Then measure confidence against the second and third replies
        if 'answer' in job['replies'][1]:
            if job['replies'][1]['answer']:
                guessedRows = job['replies'][1]['answer'][0][0]
            else:
                guessedRows = 0
        elif 'error' in job['replies'][1]:
            self._pp.pprint(job)
            print(f"Error: conf query:\n{job['replies'][1]['error']}")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if 'answer' in job['replies'][2]:
            if job['replies'][2]['answer']:
                totalRows = job['replies'][2]['answer'][0][0]
            else:
                totalRows = 0
        elif 'error' in job['replies'][2]:
            self._pp.pprint(job)
            print(f"Error: conf query:\n{job['replies'][2]['error']}")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if totalRows:
            self._addToAtkRes('sumConfidenceRatios', job['spec'],
                              guessedRows / totalRows)
            self._addToAtkRes('numConfidenceRatios', job['spec'], 1)
            self._atrs['tableStats']['totalRows'] = totalRows
    else:
        # For linkability, the confidence is always 1/2
        self._addToAtkRes('sumConfidenceRatios', job['spec'], 0.5)
        self._addToAtkRes('numConfidenceRatios', job['spec'], 1)
    if 'q' in job:
        del job['q']
    return (job)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getColNames">
    <p>def <span class="ident">getColNames</span>(</p><p>self, dbType=&#39;rawDb&#39;, tableName=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Return simple list of column names</p>
<p><code>dbType</code> is one of 'rawDb' or 'anonDb'</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getColNames', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getColNames" class="source">
    <pre><code>def getColNames(self, dbType='rawDb', tableName=''):
    """Return simple list of column names
    `dbType` is one of 'rawDb' or 'anonDb'"""
    if len(tableName) == 0:
        colsAndTypes = self.getColNamesAndTypes(dbType=dbType)
    else:
        colsAndTypes = self.getColNamesAndTypes(
            dbType=dbType, tableName=tableName)
    if not colsAndTypes:
        return None
    cols = []
    for tup in colsAndTypes:
        cols.append(tup[0])
    return cols
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getColNamesAndTypes">
    <p>def <span class="ident">getColNamesAndTypes</span>(</p><p>self, dbType=&#39;rawDb&#39;, tableName=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Return raw database column names and types (or None if error)</p>
<p>dbType is one of 'rawDb' or 'anonDb' <br/>
return format: [(col,type),(col,type),...]</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getColNamesAndTypes', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getColNamesAndTypes" class="source">
    <pre><code>def getColNamesAndTypes(self, dbType='rawDb', tableName=''):
    """Return raw database column names and types (or None if error)
    dbType is one of 'rawDb' or 'anonDb' <br/>
    return format: [(col,type),(col,type),...]"""
    if len(tableName) == 0:
        # caller didn't supply a table name, so get it from the
        # class init
        tableName = self._p['table']
    # Establish connection to database
    db = getDatabaseInfo(self._p[dbType])
    if db['type'] != 'postgres' and db['type'] != 'aircloak':
        print(f"DB type '{db['type']}' must be 'postgres' or 'aircloak'")
        return None
    connStr = str(
        f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    # Query it for column names
    if db['type'] == 'postgres':
        sql = str(f"""select column_name, data_type 
                  from information_schema.columns where
                  table_name='{tableName}'""")
    elif db['type'] == 'aircloak':
        sql = str(f"show columns from {tableName}")
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f"Error: getColNamesAndTypes() query: '{e}'")
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    ret = []
    for row in ans:
        ret.append((row[0], row[1]))
    conn.close()
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getExplore">
    <p>def <span class="ident">getExplore</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait for and gather results of prior askExplore() calls.</p>
<p>Blocks until the result is available. Note that the order
in which results are received is not necesarily the order
in which <code>askExplore()</code> calls were made. <br/>
Return parameter formatted the same as with <code>getAttack()</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getExplore', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getExplore" class="source">
    <pre><code>def getExplore(self):
    """ Wait for and gather results of prior askExplore() calls.
        Blocks until the result is available. Note that the order
        in which results are received is not necesarily the order
        in which `askExplore()` calls were made. <br/>
        Return parameter formatted the same as with `getAttack()`"""
    if self._vb:
        print(f"Calling {__name__}.getExplore")
    if self._exploreCounter == 0:
        # Caller shouldn't be calling if there are no expected
        # answers, but is anyway, so just return
        return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                'stillToCome': 0}
    job = self._exploreQ.get()
    self._exploreQ.task_done()
    self._exploreCounter -= 1
    reply = job['replies'][0]
    reply['stillToCome'] = self._exploreCounter
    return (reply)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getKnowledge">
    <p>def <span class="ident">getKnowledge</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Wait for and gather results of prior askKnowledge() calls</p>
<p>Blocks until the result is available. Note that the order
in which results are received is not necesarily the order
in which <code>askKnowledge()</code> calls were made. <br/>
Return parameter formatted the same as with <code>getAttack()</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getKnowledge', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getKnowledge" class="source">
    <pre><code>def getKnowledge(self):
    """ Wait for and gather results of prior askKnowledge() calls
        Blocks until the result is available. Note that the order
        in which results are received is not necesarily the order
        in which `askKnowledge()` calls were made. <br/>
        Return parameter formatted the same as with `getAttack()`"""
    if self._vb:
        print(f"Calling {__name__}.getKnowledge")
    if self._knowledgeCounter == 0:
        # Caller shouldn't be calling if there are no expected
        # answers, but is anyway, so just return
        return {'query': {'sql': 'None'}, 'error': 'Nothing to do',
                'stillToCome': 0}
    job = self._knowledgeQ.get()
    self._knowledgeQ.task_done()
    self._knowledgeCounter -= 1
    reply = job['replies'][0]
    reply['stillToCome'] = self._knowledgeCounter
    self._atrs['base']['knowledgeGets'] += 1
    if 'cells' in reply:
        self._atrs['base']['knowledgeCells'] += reply['cells']
    return (reply)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getOpParameters">
    <p>def <span class="ident">getOpParameters</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a variety of performance measurements.</p>
<p>Useful for debugging.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getOpParameters', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getOpParameters" class="source">
    <pre><code>def getOpParameters(self):
    """ Returns a variety of performance measurements.
        Useful for debugging."""
    self._op['avQueryDuration'] = 0
    if self._op['numQueries'] > 0:
        self._op['avQueryDuration'] = (
                self._op['timeQueries'] / self._op['numQueries'])
    self._op['avCachePutDuration'] = 0
    if self._op['numCachePuts'] > 0:
        self._op['avCachePutDuration'] = (
                self._op['timeCachePuts'] / self._op['numCachePuts'])
    self._op['avCacheGetDuration'] = 0
    if self._op['numCacheGets'] > 0:
        self._op['avCacheGetDuration'] = (
                self._op['timeCacheGets'] / self._op['numCacheGets'])
    return self._op
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getPriorKnowledge">
    <p>def <span class="ident">getPriorKnowledge</span>(</p><p>self, dataColumns, method, fraction=None, count=None, selectColumn=None, colRange=[None, None], values=[None])</p>
    </div>
    

    
  
    <div class="desc"><p>Returns data from the rawDB according to a specification</p>
<p>This mimics external knowledge that an attacker may have about the data, and
influences the 'knowledge' part of the GDA Score. <br/>
    <code>dataColumns</code> is a list of column names. The data for these columns is returned <br/>
    <code>method</code> can be 'rows' or 'users'. If 'rows', then rows are selected
    according to the criteria (<code>fraction</code>, <code>count</code>, <code>selectColumn</code>, <code>colRange</code>,
    or <code>values</code>).
    If 'users', then all rows for a set of selected users is returned.
    The users are selected according to the criteria (<code>fraction</code> or <code>count</code>) <br/>
    If none of the criteria are set, or if <code>fraction</code> is set to 1.0, then all
    rows are returned (for the selected column values) One of <code>fraction</code>, <code>count</code>,
    or <code>selectColumn</code> must be set. <br/>
    <code>fraction</code> or <code>count</code> are set to obtain a random set of rows or users. If
    <code>fraction</code>, then an approximate fraction of all rows/users is selected.
    <code>fraction</code> is a value between 0 and 1.0. If <code>count</code>, then exactly <code>count</code>
    random rows/users are selected. <br/>
    <code>selectColumn</code> is set to select rows according to the values of the specified
    column. <code>selectColumn</code> is a column name. If set, then either a range of
    values (<code>colRange</code>), or a set of values (<code>values</code>) must be chosen. <br/>
    <code>colRange</code> is
    a list with two numeric or datetime values: <code>[min,max]</code>. This selects all values
    between min and max inclusive. <br/>
    <code>values</code> is a list
    of one or more values of any type. This selects all values matching those in
    the list. <br/>
    The return value is a list in this format: <br/>
        <code>[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]</code> <br/>
    where C1 corresponds to the first column in <code>dataColumns</code>, C2 corresponds to
    the second column in <code>dataColumns</code>, and so on.  <br/></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getPriorKnowledge', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getPriorKnowledge" class="source">
    <pre><code>def getPriorKnowledge(self, dataColumns, method,
        fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):
    """ Returns data from the rawDB according to a specification
    This mimics external knowledge that an attacker may have about the data, and
    influences the 'knowledge' part of the GDA Score. <br/>
        `dataColumns` is a list of column names. The data for these columns is returned <br/>
        `method` can be 'rows' or 'users'. If 'rows', then rows are selected
        according to the criteria (`fraction`, `count`, `selectColumn`, `colRange`,
        or `values`).
        If 'users', then all rows for a set of selected users is returned.
        The users are selected according to the criteria (`fraction` or `count`) <br/>
        If none of the criteria are set, or if `fraction` is set to 1.0, then all
        rows are returned (for the selected column values) One of `fraction`, `count`,
        or `selectColumn` must be set. <br/>
        `fraction` or `count` are set to obtain a random set of rows or users. If
        `fraction`, then an approximate fraction of all rows/users is selected.
        `fraction` is a value between 0 and 1.0. If `count`, then exactly `count`
        random rows/users are selected. <br/>
        `selectColumn` is set to select rows according to the values of the specified
        column. `selectColumn` is a column name. If set, then either a range of
        values (`colRange`), or a set of values (`values`) must be chosen. <br/>
        `colRange` is
        a list with two numeric or datetime values: `[min,max]`. This selects all values
        between min and max inclusive. <br/>
        `values` is a list
        of one or more values of any type. This selects all values matching those in
        the list. <br/>
        The return value is a list in this format: <br/>
            `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` <br/>
        where C1 corresponds to the first column in `dataColumns`, C2 corresponds to
        the second column in `dataColumns`, and so on.  <br/>
    """
    # Check input parameters
    if not isinstance(dataColumns, list):
        print(f"getPriorKnowledge Error: dataColumns must be a list of one or more column names")
        self.cleanUp(cleanUpCache=False, doExit=True)
    if method not in ['rows','users']:
        print(f"getPriorKnowledge Error: method must be 'rows' or 'users'")
        self.cleanUp(cleanUpCache=False, doExit=True)
    if fraction is None and count is None and selectColumn is None:
        print(f"getPriorKnowledge Error: one of fraction, count, or selectColumn must be set")
        self.cleanUp(cleanUpCache=False, doExit=True)
    if fraction and not isinstance(fraction, float):
        print(f"getPriorKnowledge Error: if set, fraction must be a float")
        self.cleanUp(cleanUpCache=False, doExit=True)
    if (fraction and (count or selectColumn)) or (count and (fraction or selectColumn)):
        print(f"getPriorKnowledge Error: only one of fraction, count, or selectColumn may be set")
        self.cleanUp(cleanUpCache=False, doExit=True)
    if count and not isinstance(count, int):
        print(f"getPriorKnowledge Error: if set, count must be an integer")
        self.cleanUp(cleanUpCache=False, doExit=True)
    if selectColumn: 
        if selectColumn not in self._colNames:
            print(f"getPriorKnowledge Error: selectColumn '{selectColumn}' is not a valid column")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if colRange == [None,None] and values == [None]:
            print(f"getPriorKnowledge Error: if selectColumn is set, one of colRange or values must be set")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if not isinstance(colRange, list):
            print(f"getPriorKnowledge Error: colRange must be a list with two values")
            self.cleanUp(cleanUpCache=False, doExit=True)
        if not isinstance(values, list) or len(values) == 0:
            print(f"getPriorKnowledge Error: values must be a list with one or more values")
            self.cleanUp(cleanUpCache=False, doExit=True)
    for col in dataColumns:
        if col not in self._colNames:
            print(f"getPriorKnowledge Error: column '{col}' is not a valid column")
            self.cleanUp(cleanUpCache=False, doExit=True)
    # Basic input checks finished
    # Establish connection to database
    db = getDatabaseInfo(self._p['rawDb'])
    connStr = str(
        f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    table = self._p['table']
    uid = self._p['uid']
    # Make the SELECT part of the SQL query
    initSql = 'SELECT '
    for col in dataColumns:
        initSql += str(f"{col}, ")
    initSql = initSql[0:-2]
    if method == 'rows' and fraction:
        sql = initSql + str(f" FROM {table} WHERE random() <= {fraction}")
        ans = self._doQuery(cur,sql)
        self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
        return(ans)
    if method == 'users' and fraction:
        sql = initSql + str(f" FROM {table} WHERE {uid} IN ")
        sql += str(f"(SELECT {uid} from (SELECT DISTINCT {uid} FROM {table}) t WHERE random() < {fraction})")
        ans = self._doQuery(cur,sql)
        self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
        return(ans)
    if method == 'rows' and colRange[0] is not None:
        sql = initSql + str(f" FROM {table} WHERE {selectColumn} >= {colRange[0]} and {selectColumn} <= {colRange[1]}")
        ans = self._doQuery(cur,sql)
        self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
        return(ans)
    if method == 'rows' and values[0] is not None:
        sql = initSql + str(f" FROM {table} WHERE {selectColumn} IN (")
        for pair in self._colNamesTypes:
            if selectColumn in pair[0]:
                colType = pair[1]
                break
        for value in values:
            if "text" in colType or "date" in colType or "time" in colType:
                sql += str(f"'{value}', ")
            else:
                sql += str(f"{value}, ")
        sql = sql[0:-2]
        sql += ")"
        ans = self._doQuery(cur,sql)
        self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
        return(ans)
    if method == 'rows' and count:
        # need to know the total number of rows
        sql = str(f"select count(*) from {table}")
        ans = self._doQuery(cur,sql)
        numRows = ans[0][0]
        # next we get some random set of rows that is certainly more than we need
        frac = (count/numRows)*2
        sql = initSql + str(f" FROM {table} WHERE random() <= {frac}")
        temp = self._doQuery(cur,sql)
        # next we scramble these so that we get a random sampling from the random sampling
        random.shuffle(temp)
        # finally pick the exact count
        ans = temp[0:count]
        self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
        return(ans)
    if method == 'users' and count:
        # get the full list of distinct UIDs
        sql = str(f"SELECT DISTINCT {uid} from {table}")
        uidList = self._doQuery(cur,sql)
        # next we scramble these so that we can get a random sampling
        random.shuffle(uidList)
        # pick the exact count of UIDs
        uidList = uidList[0:count]
        sql = initSql + str(f" FROM {table} WHERE {uid} IN (")
        for pair in self._colNamesTypes:
            if uid in pair[0]:
                colType = pair[1]
                break
        for uidVal in uidList:
            if "text" in colType or "date" in colType or "time" in colType:
                sql += str(f"'{uidVal[0]}', ")
            else:
                sql += str(f"{uidVal[0]}, ")
        sql = sql[0:-2]
        sql += ")"
        ans = self._doQuery(cur,sql)
        self._atrs['base']['knowledgeCells'] += len(dataColumns) * len(ans)
        return(ans)
    #zzzz
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getPublicColValues">
    <p>def <span class="ident">getPublicColValues</span>(</p><p>self, colName, tableName=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Return list of "publicly known" column values and counts</p>
<p>Column value has index 0, count of distinct UIDs has index 1
Must specify column name.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getPublicColValues', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getPublicColValues" class="source">
    <pre><code>def getPublicColValues(self, colName, tableName=''):
    """Return list of "publicly known" column values and counts
    Column value has index 0, count of distinct UIDs has index 1
    Must specify column name.
    """
    if len(colName) == 0:
        print(f"Must specify column 'colName'")
        return None
    if len(tableName) == 0:
        # caller didn't supply a table name, so get it from the
        # class init
        tableName = self._p['table']
    # Establish connection to database
    db = getDatabaseInfo(self._p['rawDb'])
    connStr = str(
        f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    # First we need to know the total number of distinct users
    sql = str(f"""select count(distinct {self._p['uid']})
                  from {tableName}""")
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f"Error: getPublicColValues() query: '{e}'")
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    numUid = ans[0][0]
    # Query the raw db for values in the column
    sql = str(f"""select {colName}, count(distinct {self._p['uid']})
                  from {tableName}
                  group by 1
                  order by 2 desc
                  limit 200""")
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f"Error: getPublicColValues() query: '{e}'")
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    ret = []
    for row in ans:
        # row[0] is the value, row[1] is the count
        if (((row[1] / numUid) > 0.002) and
                (row[1] >= 50)):
            ret.append((row[0], row[1]))
    conn.close()
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getResults">
    <p>def <span class="ident">getResults</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns all of the compiled attack results.</p>
<p>This can be input to class <code>gdaScores()</code> and method
<code>gdaScores.addResult()</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getResults', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getResults" class="source">
    <pre><code>def getResults(self):
    """ Returns all of the compiled attack results.
        This can be input to class `gdaScores()` and method
        `gdaScores.addResult()`."""
    # Add the operational parameters
    self._atrs['operational'] = self.getOpParameters()
    self._cleanPasswords()
    return self._atrs
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getTableCharacteristics">
    <p>def <span class="ident">getTableCharacteristics</span>(</p><p>self, tableName=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the full contents of the table characteristics</p>
<p>Return value is a dict indexed by column name: <br/></p>
<pre><code>{ '&lt;colName&gt;':
    {
        'av_rows_per_vals': 3.93149,
        'av_uids_per_val': 0.468698,
        'column_label': 'continuous',
        'column_name': 'dropoff_latitude',
        'column_type': 'real',
        'max': '898.29382000000000',
        'min': '-0.56333297000000',
        'num_distinct_vals': 24216,
        'num_rows': 95205,
        'num_uids': 11350,
        'std_rows_per_val': 10.8547,
        'std_uids_per_val': 4.09688},
    }
}
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getTableCharacteristics', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getTableCharacteristics" class="source">
    <pre><code>def getTableCharacteristics(self, tableName=''):
    """Returns the full contents of the table characteristics
       Return value is a dict indexed by column name: <br/>
           { '<colName>':
               {
                   'av_rows_per_vals': 3.93149,
                   'av_uids_per_val': 0.468698,
                   'column_label': 'continuous',
                   'column_name': 'dropoff_latitude',
                   'column_type': 'real',
                   'max': '898.29382000000000',
                   'min': '-0.56333297000000',
                   'num_distinct_vals': 24216,
                   'num_rows': 95205,
                   'num_uids': 11350,
                   'std_rows_per_val': 10.8547,
                   'std_uids_per_val': 4.09688},
               }
           }
    """
    if len(tableName) == 0:
        # caller didn't supply a table name, so get it from the
        # class init
        tableName = self._p['table']
    # Modify table name to the default for the characteristics table
    tableName += '_char'
    # Establish connection to database
    db = getDatabaseInfo(self._p['rawDb'])
    connStr = str(
        f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    # Set up return dict
    ret = {}
    # Query it for column names
    sql = str(f"""select column_name, data_type 
              from information_schema.columns where
              table_name='{tableName}'""")
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f"Error: getTableCharacteristics() query: '{e}'")
        self.cleanUp(cleanUpCache=False, doExit=True)
    cols = cur.fetchall()
    # Make index for column name (should be 0, but just to be sure)
    for colNameIndex in range(len(cols)):
        if cols[colNameIndex][0] == 'column_name':
            break
    # Query it for table contents
    sql = str(f"SELECT * FROM {tableName}")
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f"Error: getTableCharacteristics() query: '{e}'")
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    for row in ans:
        colName = row[colNameIndex]
        ret[colName] = {}
        for i in range(len(row)):
            ret[colName][cols[i][0]] = row[i]
    conn.close()
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getTableNames">
    <p>def <span class="ident">getTableNames</span>(</p><p>self, dbType=&#39;rawDb&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Return database table names</p>
<p>dbType is one of 'rawDb' or 'anonDb' <br/>
Table names returned as list, unless error then return None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getTableNames', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getTableNames" class="source">
    <pre><code>def getTableNames(self, dbType='rawDb'):
    """Return database table names
    dbType is one of 'rawDb' or 'anonDb' <br/>
    Table names returned as list, unless error then return None"""
    # Establish connection to database
    db = getDatabaseInfo(self._p[dbType])
    if db['type'] != 'postgres' and db['type'] != 'aircloak':
        print(f"DB type '{db['type']}' must be 'postgres' or 'aircloak'")
        return None
    connStr = str(
        f"host={db['host']} port={db['port']} dbname={db['dbname']} user={db['user']} password={db['password']}")
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    # Query it for column names
    if db['type'] == 'postgres':
        sql = """SELECT tablename
                 FROM pg_catalog.pg_tables
                 WHERE schemaname != 'pg_catalog' AND
                       schemaname != 'information_schema'"""
    elif db['type'] == 'aircloak':
        sql = "show tables"
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f"Error: getTableNames() query: '{e}'")
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    ret = []
    for row in ans:
        ret.append(row[0])
    conn.close()
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.getUidColName">
    <p>def <span class="ident">getUidColName</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the name of the UID column</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.getUidColName', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.getUidColName" class="source">
    <pre><code>def getUidColName(self):
    """ Returns the name of the UID column"""
    return self._p['uid']
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.putCacheWrapper">
    <p>def <span class="ident">putCacheWrapper</span>(</p><p>self, conn, cur, query, reply)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.putCacheWrapper', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.putCacheWrapper" class="source">
    <pre><code>def putCacheWrapper(self, conn, cur, query, reply):
    self._putCache(conn, cur, query, reply)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.setVerbose">
    <p>def <span class="ident">setVerbose</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets Verbose to True</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.setVerbose', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.setVerbose" class="source">
    <pre><code>def setVerbose(self):
    """Sets Verbose to True"""
    self._vb = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="gdaAttack.gdaAttack.unsetVerbose">
    <p>def <span class="ident">unsetVerbose</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets Verbose to False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-gdaAttack.gdaAttack.unsetVerbose', this);">Show source &equiv;</a></p>
  <div id="source-gdaAttack.gdaAttack.unsetVerbose" class="source">
    <pre><code>def unsetVerbose(self):
    """Sets Verbose to False"""
    self._vb = False
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="gdaAttack.gdaAttack.cacheQueue" class="name">var <span class="ident">cacheQueue</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="gdaAttack.gdaAttack.cacheThreadObject" class="name">var <span class="ident">cacheThreadObject</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
